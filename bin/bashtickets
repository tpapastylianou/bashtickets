#!/bin/bash

################################################################################
###
### Bashtickets v0.0.1
###
### Code sections in this file:
###
### - Script constants
###   - Bashticket directories
###   - Error codes
### - Function definitions
###   - Helper functions
###     - error
###     - trycatch
###     - check_bashtickets_installation
###     - is_valid_bashtickets_repository
###     - check_repo
###     - load_config
###     - display_usage
###   - Bashticket Commands
###     - initialise_bashtickets_repository
###     - display_help
### - Main body
###   - Perform initial sanity checks
###   - Execute bashtickets command
###
################################################################################



####################
### Script constants
####################

# Declare directories where relevant bashticket files should reside
BT_BIN_DIR="$(dirname "$BASH_SOURCE" | xargs realpath)"
BT_ROOT_DIR="${BT_BIN_DIR%"/bin"}"
BT_BIN_DIR="${BT_ROOT_DIR/bin}"
BT_SHARE_DIR="$BT_ROOT_DIR/share"
BT_DOC_DIR="$BT_SHARE_DIR/doc"

# Declare exit statuses for various errors
declare -i EXIT_STATUS__INVALID_BASHTICKETS_INSTALLATION=2
declare -i EXIT_STATUS__NOT_A_VALID_BASHTICKETS_REPOSITORY=3
declare -i EXIT_STATUS__FAILED_TO_INITIALIZE_REPOSITORY=4
declare -i EXIT_STATUS__FAILED_TO_CREATE_TICKET_OR_MILESTONE=5
declare -i EXIT_STATUS__FAILED_TO_CREATE_TICKET=6
declare -i EXIT_STATUS__FAILED_TO_CREATE_MILESTONE=7
declare -i EXIT_STATUS__FAILED_TO_CLOSE_TICKET=8
declare -i EXIT_STATUS__FAILED_TO_REOPEN_TICKET=9
declare -i EXIT_STATUS__FAILED_TO_ADD_COMMENT_TO_TICKET=10
declare -i EXIT_STATUS__FAILED_TO_ASSIGN_TICKETS_TO_MILESTONE=11

declare -i EXIST_STATUS__INVALID_SUBCOMMAND=100



########################
### Function definitions
########################

# ----------------
# Helper functions
# ----------------

function error () {
# A useful, 'libstderred.so' compatible function for safely echoing error
# messages to stderr (see: https://unix.stackexchange.com/a/164223)

    awk "BEGIN { print \"$*\" > \"/dev/stderr\" }"
}




function trycatch () {

    declare COMMAND=( "${@: 1: ${#@} - 1}" )   # Collect all input arguments
                                               # except last, as an array

    declare -i EXITSTATUS="${@: -1}"   # Get last input argument only

    if   "${COMMAND[@]}"   # Run the respective command with accompanying
                           # arguments

    then :

    else exit $EXITSTATUS   # If the above command exited with non-zero status,
                            # abort this script with the exit status provided as
                            # the last input argument to this function
    fi
}




function check_bashtickets_installation () {
# Assert everything is installed in the expected locations (relative to this
# script)

    if     test -d "$BT_ROOT_DIR"      &&
           test -d "$BT_BIN_DIR"       &&
           test -d "$BT_SHARE_DIR"     &&
           test -d "$BT_DOC_DIR"

    then   :   # i.e. do nothing

    else   error "Error: did not detect a valid installation of bashtickets."
           error "Please re-install and try again."
           return 1
    fi
}




function is_valid_bashtickets_repository () {
# In order for a directory to be a valid 'bashtickets repository', it needs to
# contain a directory called '.bashtickets'; this directory should contain a
# file called "config", which should be sourceable without errors.
# Furthermore, it should contain a directory called 'tickets', and a directory
# called 'milestones'.

    if   test -d ./.bashtickets
    then :
    else error "Error: Not a valid bashtickets repository ('.bashtickets' directory missing)"
         return 1
    fi

    if   test -f ./.bashtickets/config
    then :
    else error "Error: Not a valid bashtickets repository ('.bashtickets/config' file missing)"
         return 1
    fi

    # test if the config file can be sourced without errors
    ( set -e; source ./.bashtickets/config )
    if   test $? -eq 0
    then :
    else error "Error: Not a valid bashtickets repository (errors found in '.bashtickets/config' file)"
         return 1
    fi

    if   test -d ./tickets
    then :
    else error "Error: Not a valid bashtickets repository ('tickets' directory missing)"
         return 1
    fi

    if   test -d ./milestones
    then :
    else error "Error: Not a valid bashtickets repository ('milestones' directory missing)"
         return 1
    fi

  # If all tests passed successfully, exit normally.
    return 0
}




function check_repo () {

    trycatch "is_valid_bashtickets_repository" \
             $EXIT_STATUS__NOT_A_VALID_BASHTICKETS_REPOSITORY
}




function load_config () {

    CONFIG_FILE="$( realpath ./.bashtickets/config )"
    source "$CONFIG_FILE"
}




function display_usage () { echo "Displaying usage ... TODO"; exit $EXIST_STATUS__INVALID_SUBCOMMAND; }



# -------------------
# Bashticket commands
# -------------------

function initialise_bashtickets_repository () {
# command: 'init'

  # Ensure this command was called with no arguments
    if   test ${#@} -gt 0
    then "display_usage"
         return 1
    fi

  # Desired case: Empty directory detected
    if     test $( ls -A | wc -l ) -eq 0   # empty directory detected

    then   if     mkdir .bashtickets

           then   :

           else   error "Error: Could not create a '.bashtickets' subdirectory in the current directory."
                  error "       Please ensure you have the necessary permissions."
                  return 1
           fi


           if   cp  "$BT_DOC_DIR/sample_config" ".bashtickets/config"

           then :

           else   error "Error: Could not create a 'config' file in the '.bashtickets' subdirectory."
                  error "       Please ensure you have the necessary permissions."
                  return 1
           fi


           if     mkdir tickets

           then   :

           else   error "Error: Could not create 'tickets' directory."
                  return 1
           fi


           if     mkdir milestones

           then   :

           else   error "Error: Could not create 'milestones' directory."
                  return 1
           fi

           echo   "Bashtickets repository initialised successfully."

    elif   is_valid_bashtickets_repository 2> /dev/null

    then   error "Error: Current directory is already a valid bashtickets repository"
           error "       Aborting..."
           return 1

    else   error "Error: Non-empty directory detected."
           error "       To initialise as a bashtickets repository, please delete all files"
           error "       (including hidden files) and try again."
           return 1
    fi
}




function display_help  () {
# command: help | h

    echo "Showing help... TODO"
    return 0
}




function new_ticket_or_milestone () {
    case "$1" in
        ("ticket")     shift && new_ticket    "$@" ;;
        ("milestone")  shift && new_milestone "$@" ;;
        (*)            error "Error: invalid argument given to 'new'."
                       error "Valid arguments are 'ticket' or 'milestone'."
                       return 1 ;;
    esac
}




function new_ticket () {
    if   test ${#@} -gt 0
    then error "Error: Incorrect arguments provided to new_ticket function"
         echo
         display_usage
         return 1
    fi

  # Capture ticket path and template onto the relevant variables
    TICKETS_PATH="$( realpath ./tickets )"
    TICKET_TEMPLATE="$BT_DOC_DIR/ticket.template"

    cd $TICKETS_PATH


  # If this is the first ticket, start numbering from 1; otherwise, find the
   # last ticket number, and increment by one.

    if     test -f 1.ticket
    then   LAST_TICKET_NUM=$(ls *.ticket | sort -n | tail -n -1)   # list files, sort in numerical (not alphabetical) order, and keep last filename
           LAST_TICKET_NUM=${LAST_TICKET_NUM%.ticket}   # parameter expansion: remove '.ticket' suffix
           NEW_TICKET_NUM=$(( $LAST_TICKET_NUM + 1 ))
    else   NEW_TICKET_NUM=1
    fi

    NEW_TICKET_FILE="${NEW_TICKET_NUM}.ticket"

  # Create a new ticket from template
    cp "$TICKET_TEMPLATE" "${NEW_TICKET_FILE}"

  # Update ticket number
    sed -i "s/Ticket No.: /Ticket No.: ${NEW_TICKET_NUM}/" "${NEW_TICKET_FILE}"

  # Try to set owner and reporter automatically:
    WHOAMI=$(whoami)
    WHOAMI=${WHOAMI^}   # parameter expansion: make first character uppercase
    sed -i "s/Reporter: /Reporter: $WHOAMI/" "${NEW_TICKET_FILE}"
    sed -i "s/Owner:/Owner: $WHOAMI/" "${NEW_TICKET_FILE}"

  # Select a valid type:
    echo "Select a valid ticket type:"
    declare -i REPLY   # The user's input is assigned to this variable; we want to ensure it only takes numeric values
    select TICKET_TYPE in "${TICKET_TYPES[@]}"   # TICKET_TYPES obtained from config
    do
        if   test $REPLY -gt 0 && test $REPLY -le ${#TICKET_TYPES[@]}
        then sed -i "s/Type: /Type: $TICKET_TYPE/" "${NEW_TICKET_FILE}"
             break
        else error "Invalid selection, please chose a number between 1 and ${#TICKET_TYPES[@]}" && exit 1
        fi
    done
    declare +i REPLY

  # Select a valid priority:
    echo
    echo "Select a valid ticket priority"
    declare -i REPLY   # The user's input is assigned to this variable; we want to ensure it only takes numeric values
    select TICKET_PRIORITY in "${TICKET_PRIORITY_LEVELS[@]}"   # TICKET_PRIORITY_LEVELS obtained from config
    do
        if   test $REPLY -gt 0 && test $REPLY -le ${#TICKET_PRIORITY_LEVELS[@]}
        then sed -i "s/Priority: /Priority: ${TICKET_PRIORITY%% *}/" "${NEW_TICKET_FILE}"   # Remove everything in the priority string after the first space (i.e. the explanation of the priority level)
             break
        else error "Invalid selection, please chose a number between 1 and ${#TICKET_PRIORITY_LEVELS[@]}" && exit 1
        fi
    done
    declare +i REPLY

  # Set today's date
    TODAY=$(date +"%Y-%m-%d")
    sed -i "s/Date: /Date: $TODAY/" "${NEW_TICKET_FILE}"

  # Declare status as Open
    sed -i "s/Status: /Status: Open/" "${NEW_TICKET_FILE}"

  # Save current status of ticket before manual editing
    UNEDITED_TICKET="$(cat $NEW_TICKET_FILE)"

  # Open resulting file in the user's editor of choice, as detected by the
   # EDITOR environmental variable. This can be overriden per bashtickets
    # repository, by assigning to this variable in the repository's config file
    # instead. If the EDITOR variable is not defined at all, nano is used as the
    # default editor.

    if   test $EDITOR = "vim"
    then vim '+cal cursor(2,14)' "${NEW_TICKET_FILE}"
    else nano +2,14 "${NEW_TICKET_FILE}"
    fi

    EDITED_TICKET="$(cat $NEW_TICKET_FILE)"

    if   test "$UNEDITED_TICKET" = "$EDITED_TICKET"
    then error "Error: No edits detected."
         error "Aborting new ticket creation."
         rm "$NEW_TICKET_FILE"
         exit 1
    else echo
         echo "Ticket No. ${NEW_TICKET_NUM} created successfully"
         echo
    fi
}





#############
### Main body
#############

# -----------------------------
# Perform initial sanity checks
# -----------------------------

# Ensure we have a valid bashtickets installation
trycatch "check_bashtickets_installation" $EXIT_STATUS__INVALID_BASHTICKETS_INSTALLATION

# Ensure valid bashtickets repository for commands that require it
case "$1" in

    ( "init"   | "help"    | "h" )
        ;;   # do nothing for now


    ( "update"  | "up" | "show"   | "sh"     | "list"   | "ls" | "add"  | \
      "comment" | "a"  | "m"      | "assign" | "close"  | "cl" | "open" | \
      "reopen"  | "re" | "op"     | "new"    | "create" | "nt" | "ct"   | \
      "nm"      | "cm" | "status" | "st"     | "remove" | "rm" | "edit" | \
      "ed"  )

        trycatch "check_repo" \
                 $EXIT_STATUS__NOT_A_VALID_BASHTICKETS_REPOSITORY
        ;;


    ( * )   # Unknown / invalid command

        display_usage && exit 1
        ;;
esac


# ---------------------------
# Execute bashtickets command
# ---------------------------

load_config

case "$1" in
    ("init")                             trycatch "initialise_bashtickets_repository" $EXIT_STATUS__FAILED_TO_INITIALIZE_REPOSITORY ;;
    ("update" | "up")                    echo "Updating Milestones" ;;
    ("show" | "sh" | "list" | "ls" )     echo "Showing tickets" ;;
    ( "add" | "comment" | "a" | "m")     shift && trycatch "add_comment_to_ticket" "$@" $EXIT_STATUS__FAILED_TO_ADD_COMMENT_TO_TICKET ;;
    ("assign")                           shift && trycatch "assign_tickets_to_milestone" "$@" $EXIT_STATUS__FAILED_TO_ASSIGN_TICKETS_TO_MILESTONE ;;
    ("close" | "cl")                     shift && trycatch "close_ticket_with_comment" "$@" $EXIT_STATUS__FAILED_TO_CLOSE_TICKET ;;
    ("open" | "reopen" | "re" | "op" )   shift && trycatch "reopen_ticket" "$@" $EXIT_STATUS__FAILED_TO_REOPEN_TICKET ;;
    ("new" | "create" )                  shift && trycatch "new_ticket_or_milestone" "$@" $EXIT_STATUS__FAILED_TO_CREATE_TICKET_OR_MILESTONE ;;
    ("nt" | "ct" )                       shift && trycatch "new_ticket" "$@" $EXIT_STATUS__FAILED_TO_CREATE_TICKET ;;
    ("nm" | "cm" )                       shift && trycatch "new_milestone" "$@" $EXIT_STATUS__FAILED_TO_CREATE_MILESTONE ;;
    ("help" | "h")                       display_help ;;
    ("status" | "st")                    echo "Displaying milestone status (all/open/closed)" ;;
    ("remove" | "rm")                    echo "Removing last ticket / milestone or by number" ;;
    ("edit" | "ed")                      echo "Edit ticket / milestone" ;;
    (*)                                  display_usage && exit 1 ;;
esac
