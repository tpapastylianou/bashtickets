#!/bin/bash

################################################################################
###
### Bashtickets v0.0.1
###
### Code sections in this file:
###
### - Script constants
###   - Bashticket directories
###   - Error codes
### - Function definitions
###   - Helper functions
###     - error
###     - trycatch
###     - check_bashtickets_installation
###     - is_valid_bashtickets_repository
###     - check_repo
###     - load_config
###     - display_usage
###   - Bashticket Commands
###     - initialise_bashtickets_repository
###     - display_help
### - Main body
###   - Perform initial sanity checks
###   - Execute bashtickets command
###
################################################################################



####################
### Script constants
####################

# Declare directories where relevant bashticket files should reside
BT_BIN_DIR="$(dirname "$BASH_SOURCE" | xargs realpath)"
BT_ROOT_DIR="${BT_BIN_DIR%"/bin"}"
BT_BIN_DIR="${BT_ROOT_DIR/bin}"
BT_SHARE_DIR="$BT_ROOT_DIR/share"
BT_DOC_DIR="$BT_SHARE_DIR/doc"

TICKET_TEMPLATE="$BT_DOC_DIR/ticket.template"
MILESTONE_TEMPLATE="$BT_DOC_DIR/milestone.template"

# Assuming a valid repo, the following paths should exist
REPO_PATH="$( realpath . )"
TICKETS_PATH="$REPO_PATH/tickets"
MILESTONES_PATH="$REPO_PATH/milestones"

# Declare exit statuses for various errors
declare -i EXIT_STATUS__INVALID_BASHTICKETS_INSTALLATION=2
declare -i EXIT_STATUS__NOT_A_VALID_BASHTICKETS_REPOSITORY=3
declare -i EXIT_STATUS__FAILED_TO_INITIALIZE_REPOSITORY=4
declare -i EXIT_STATUS__FAILED_TO_CREATE_TICKET_OR_MILESTONE=5
declare -i EXIT_STATUS__FAILED_TO_CREATE_TICKET=6
declare -i EXIT_STATUS__FAILED_TO_CREATE_MILESTONE=7
declare -i EXIT_STATUS__FAILED_TO_CLOSE_TICKET=8
declare -i EXIT_STATUS__FAILED_TO_REOPEN_TICKET=9
declare -i EXIT_STATUS__FAILED_TO_ADD_COMMENT_TO_TICKET=10
declare -i EXIT_STATUS__FAILED_TO_ASSIGN_TICKETS_TO_MILESTONE=11

declare -i EXIT_STATUS__INVALID_SUBCOMMAND=100
declare -i EXIT_STATUS__INVALID_SUBCOMMAND_SYNTAX=101
declare -i EXIT_STATUS__OTHER_ERROR=102   # in theory this should never happen

########################
### Function definitions
########################

# ----------------
# Helper functions
# ----------------

function error () {
# A useful, 'libstderred.so' compatible function for safely echoing error
# messages to stderr (see: https://unix.stackexchange.com/a/164223)

    awk "BEGIN { print \"$*\" > \"/dev/stderr\" }"
}




function trycatch () {

    local COMMAND=( "${@: 1: ${#@} - 1}" )   # Collect all input arguments
                                               # except last, as an array

    local -i EXITSTATUS="${@: -1}"   # Get last input argument only (as integer)

    if   "${COMMAND[@]}"   # Run the respective command with accompanying
                           # arguments, and check its exit status

    then :

    else exit $EXITSTATUS   # If the above command exited with non-zero status,
                            # abort this script with the exit status provided as
                            # the last input argument to this function
    fi
}




function check_bashtickets_installation () {
# Assert everything is installed in the expected locations (relative to this
# script)

    if     test -d "$BT_ROOT_DIR"      &&
           test -d "$BT_BIN_DIR"       &&
           test -d "$BT_SHARE_DIR"     &&
           test -d "$BT_DOC_DIR"

    then   :   # i.e. do nothing

    else   error "Error: did not detect a valid installation of bashtickets."
           error "Please re-install and try again."
           return 1
    fi
}




function is_valid_bashtickets_repository () {
# In order for a directory to be a valid 'bashtickets repository', it needs to
# contain a directory called '.bashtickets'; this directory should contain a
# file called "config", which should be sourceable without errors.
# Furthermore, it should contain a directory called 'tickets', and a directory
# called 'milestones'.

    if   test -d ./.bashtickets
    then :
    else error "Error: Not a valid bashtickets repository ('.bashtickets' directory missing)"
         return 1
    fi

    if   test -f ./.bashtickets/config
    then :
    else error "Error: Not a valid bashtickets repository ('.bashtickets/config' file missing)"
         return 1
    fi

    # test if the config file can be sourced without errors
    ( set -e; source ./.bashtickets/config )
    if   test $? -eq 0
    then :
    else error "Error: Not a valid bashtickets repository (errors found in '.bashtickets/config' file)"
         return 1
    fi

    if   test -d ./tickets
    then :
    else error "Error: Not a valid bashtickets repository ('tickets' directory missing)"
         return 1
    fi

    if   test -d ./milestones
    then :
    else error "Error: Not a valid bashtickets repository ('milestones' directory missing)"
         return 1
    fi

  # If all tests passed successfully, exit normally.
    return 0
}




function check_repo () {

    trycatch "is_valid_bashtickets_repository" \
             $EXIT_STATUS__NOT_A_VALID_BASHTICKETS_REPOSITORY
}




function load_config () {

    declare -g CONFIG_FILE="$( realpath ./.bashtickets/config )"
    source "$CONFIG_FILE"
}




function display_usage () {
# TODO: This function will need to display appropriate usage for the bashtickets
# main program, AS WELL AS for the relevant subcommands (threfore it will
# require processing of an input argument).

  case $1 in

      ('assign_tickets_to_milestone')
          echo "Usage:"
          echo "    $(basename $0) assign <ticket> [<ticket2> <ticket3> ... <ticketN>] <milestone>"
          echo
          echo "e.g.:"
          echo "    $(basename $BASH_SOURCE) assign 1.ticket 2.ticket 1.milestone"
          echo
          echo "or simply:"
          echo "    $(basename $BASH_SOURCE) 1 2 1"
          echo
          echo "Using '0' as the milestone removes any existing milestones from the specified tickets instead"
          ;;

      ('update_milestones')
          echo "Usage:"
          echo
          echo "    $(basename $0) [milestone1 milestone2 ... milestoneN]"
          echo
          echo "Updates all or specific milestones from tickets"
          echo
          echo "e.g.:"
          echo "    $(basename $0) 001.milestone   # update milestone 001 only"
          echo "    $(basename $0) 001             # short version of above"
          echo "    $(basename $0) 001 002 003     # update milestones 001 002 and 003 only"
          echo "    $(basename $0)                 # update all milestones"
          ;;

      ('show_open_tickets_by_milestone')
          echo "Usage:"
          echo "    $(basename $0) <milestone>"
          echo
          echo "e.g.:"
          echo "    $(basename $0) 001.milestone"
          echo
          echo "or simply:"
          echo "    $(basename $0) 001"
          echo
          echo "Note: Using '0' as the milestone displays tickets that are not assigned to any milestones"
          ;;

      ('show_closed_tickets_by_milestone')
          echo "Usage:"
          echo "    $(basename $0) <milestone>"
          echo
          echo "e.g.:"
          echo "    $(basename $0) 001.milestone"
          echo
          echo "or simply:"
          echo "    $(basename $0) 001"
          echo
          echo "Note: Using '0' as the milestone displays tickets that are not assigned to any milestones"
          ;;

      (*)
          echo "Displaying usage ... TODO";
          ;;
  esac
}



function get_default_milestone_startdate () {
# Note: This function can be overridden in the config if desired
  date +"%Y-%m-%d"   # i.e. today's date
}





function get_default_milestone_deadline () {
# Note: This function can be overridden in the config if desired
  local STARTDATE="$1"
  date --date="$STARTDATE +1 month" +"%Y-%m-%d"
}




function is_valid_ticket () {

   local TICKET="${1%.ticket}.ticket"

 # Test if ticket file exists in the first place
   if   test -f "$TICKETS_PATH/$TICKET"
   then :
   else error "Warning: ticket '$TICKET' does not exist in '$TICKETS_PATH'."
        return 1
   fi

 # Test if ticket file is of valid form
   if   head "$TICKETS_PATH/$TICKET" -n +1 | egrep "^ Ticket No.: " > /dev/null
   then :
   else error "Warning: file '$TICKET' does not appear to be of valid ticket syntax"
        error "         (line 1 should start with: ' Ticket No.: ')"
        return 1
   fi
}





function is_valid_milestone () {

   local MILESTONE="${1%.milestone}.milestone"

 # Test if milestone file exists in the first place
   if   test -f "$MILESTONES_PATH/$MILESTONE"
   then :
   else error "Warning: milestone '$MILESTONE' does not exist in '$MILESTONES_PATH'."
        return 1
   fi

 # Test if milestone file is of valid form
   if   head "$MILESTONES_PATH/$MILESTONE" -n +1 | egrep "^Milestone No.: " > /dev/null
   then :
   else error "Warning: file '$MILESTONE' does not appear to be of valid milestone syntax"
        error "         (line 1 should start with: 'Milestone No.: ')"
        return 1
   fi
}



# -------------------
# Bashticket commands
# -------------------

function initialise_bashtickets_repository () {
# command: 'init'

  # Ensure this command was called with no arguments
    if   test ${#@} -gt 0
    then "display_usage"
         return 1
    fi

  # Desired case: Empty directory detected
    if     test $( ls -A | wc -l ) -eq 0   # empty directory detected

    then   if     mkdir .bashtickets

           then   :

           else   error "Error: Could not create a '.bashtickets' subdirectory in the current directory."
                  error "       Please ensure you have the necessary permissions."
                  return 1
           fi


           if   cp  "$BT_DOC_DIR/sample_config" ".bashtickets/config"

           then :

           else   error "Error: Could not create a 'config' file in the '.bashtickets' subdirectory."
                  error "       Please ensure you have the necessary permissions."
                  return 1
           fi


           if     mkdir tickets

           then   :

           else   error "Error: Could not create 'tickets' directory."
                  return 1
           fi


           if     mkdir milestones

           then   :

           else   error "Error: Could not create 'milestones' directory."
                  return 1
           fi

           echo   "Bashtickets repository initialised successfully."

    elif   is_valid_bashtickets_repository 2> /dev/null

    then   error "Error: Current directory is already a valid bashtickets repository"
           error "       Aborting..."
           return 1

    else   error "Error: Non-empty directory detected."
           error "       To initialise as a bashtickets repository, please delete all files"
           error "       (including hidden files) and try again."
           return 1
    fi
}




function display_help  () {
# command: help | h

    echo "Showing help... TODO"
    return 0
}




function new_ticket_or_milestone () {
    case "$1" in
        ("ticket")     shift && new_ticket    "$@" ;;
        ("milestone")  shift && new_milestone "$@" ;;
        (*)            error "Error: invalid argument given to 'new'."
                       error "Valid arguments are 'ticket' or 'milestone'."
                       return 1 ;;
    esac
}




function new_ticket () {
    if   test ${#@} -gt 0
    then error "Error: Incorrect arguments provided to new_ticket function"
         echo
         display_usage
         return 1
    fi


    cd $TICKETS_PATH


  # If this is the first ticket, start numbering from 1; otherwise, find the
   # last ticket number, and increment by one.

    if     test -f 1.ticket
    then   LAST_TICKET_NUM=$(ls *.ticket | sort -n | tail -n -1)   # list files, sort in numerical (not alphabetical) order, and keep last filename
           LAST_TICKET_NUM=${LAST_TICKET_NUM%.ticket}   # parameter expansion: remove '.ticket' suffix
           NEW_TICKET_NUM=$(( $LAST_TICKET_NUM + 1 ))
    else   NEW_TICKET_NUM=1
    fi

    NEW_TICKET_FILE="${NEW_TICKET_NUM}.ticket"

  # Create a new ticket from template
    cp "$TICKET_TEMPLATE" "${NEW_TICKET_FILE}"

  # Update ticket number
    sed -i "s/Ticket No.: /Ticket No.: ${NEW_TICKET_NUM}/" "${NEW_TICKET_FILE}"

  # Try to set owner and reporter automatically:
    WHOAMI=$(whoami)
    WHOAMI=${WHOAMI^}   # parameter expansion: make first character uppercase
    sed -i "s/Reporter: /Reporter: $WHOAMI/" "${NEW_TICKET_FILE}"
    sed -i "s/Owner:/Owner: $WHOAMI/" "${NEW_TICKET_FILE}"

  # Select a valid type:
    echo "Select a valid ticket type:"
    declare -i REPLY   # The user's input is assigned to this variable; we want to ensure it only takes numeric values
    select TICKET_TYPE in "${TICKET_TYPES[@]}"   # TICKET_TYPES obtained from config
    do
        if   test $REPLY -gt 0 && test $REPLY -le ${#TICKET_TYPES[@]}
        then sed -i "s/Type: /Type: $TICKET_TYPE/" "${NEW_TICKET_FILE}"
             break
        else error "Invalid selection, please chose a number between 1 and ${#TICKET_TYPES[@]}" && exit 1
        fi
    done
    declare +i REPLY

  # Select a valid priority:
    echo
    echo "Select a valid ticket priority"
    declare -i REPLY   # The user's input is assigned to this variable; we want to ensure it only takes numeric values
    select TICKET_PRIORITY in "${TICKET_PRIORITY_LEVELS[@]}"   # TICKET_PRIORITY_LEVELS obtained from config
    do
        if   test $REPLY -gt 0 && test $REPLY -le ${#TICKET_PRIORITY_LEVELS[@]}
        then sed -i "s/Priority: /Priority: ${TICKET_PRIORITY%% *}/" "${NEW_TICKET_FILE}"   # Remove everything in the priority string after the first space (i.e. the explanation of the priority level)
             break
        else error "Invalid selection, please chose a number between 1 and ${#TICKET_PRIORITY_LEVELS[@]}" && exit 1
        fi
    done
    declare +i REPLY

  # Set today's date
    TODAY=$(date +"%Y-%m-%d")
    sed -i "s/Date: /Date: $TODAY/" "${NEW_TICKET_FILE}"

  # Declare status as Open
    sed -i "s/Status: /Status: Open/" "${NEW_TICKET_FILE}"

  # Save current status of ticket before manual editing
    UNEDITED_TICKET="$(cat $NEW_TICKET_FILE)"

  # Open resulting file in the user's editor of choice, as detected by the
   # EDITOR environmental variable. This can be overriden per bashtickets
    # repository, by assigning to this variable in the repository's config file
    # instead. If the EDITOR variable is not defined at all, nano is used as the
    # default editor.

    if   test $EDITOR = "vim"
    then vim '+cal cursor(2,14)' "${NEW_TICKET_FILE}"
    else nano +2,14 "${NEW_TICKET_FILE}"
    fi

    EDITED_TICKET="$(cat $NEW_TICKET_FILE)"

    if   test "$UNEDITED_TICKET" = "$EDITED_TICKET"
    then error "Error: No edits detected."
         error "Aborting new ticket creation."
         rm "$NEW_TICKET_FILE"
         exit 1
    else echo
         echo "Ticket No. ${NEW_TICKET_NUM} created successfully"
         echo
    fi
}




function new_milestone () {

  if   test ${#@} -gt 0
  then error "Error: Incorrect arguments provided to new_milestone function"
       echo
       display_usage
       exit 1
  fi

# Capture milestones path and template onto the relevant variables

  cd $MILESTONES_PATH

# If this is the first milestone, start numbering from 1; otherwise, find the
 # last milestone number, and increment by one.

  if     test -f 1.milestone
  then   LAST_MILESTONE_NUM=$(ls *.milestone | sort -n | tail -n -1)   # list files, sort in numerical (not alphabetical) order, and keep last filename
         LAST_MILESTONE_NUM=${LAST_MILESTONE_NUM%.milestone}   # parameter expansion: remove '.milestone' suffix
         NEW_MILESTONE_NUM=$(( $LAST_MILESTONE_NUM + 1 ))
  else   NEW_MILESTONE_NUM=1
  fi

  NEW_MILESTONE_FILE="${NEW_MILESTONE_NUM}.milestone"

# Create a new milestone from template
  cp "$MILESTONE_TEMPLATE" "${NEW_MILESTONE_FILE}"

# Update milestone number
  sed -i "s/Milestone No.: /Milestone No.: ${NEW_MILESTONE_NUM}/" "${NEW_MILESTONE_FILE}"

# Set start date from default
  DEFAULT_STARTDATE="$(get_default_milestone_startdate)"
  sed -i "s/Startdate: /Startdate: $DEFAULT_STARTDATE/" "${NEW_MILESTONE_FILE}"

# Set deadline from default
  DEFAULT_DEADLINE="$( get_default_milestone_deadline $DEFAULT_STARTDATE )"
  sed -i "s/Deadline: /Deadline: $DEFAULT_DEADLINE/" "${NEW_MILESTONE_FILE}"

# Save current status of ticket before manual editing
  UNEDITED_MILESTONE="$(cat $NEW_MILESTONE_FILE)"

# Open resulting file in vim or nano for further editing, place cursor at Title field
  if   test $EDITOR = "vim"
  then vim '+cal cursor(2,16)' "${NEW_MILESTONE_FILE}"
  else nano +2,16 "${NEW_MILESTONE_FILE}"
  fi

  EDITED_MILESTONE="$(cat $NEW_MILESTONE_FILE)"

  if   test "$UNEDITED_MILESTONE" = "$EDITED_MILESTONE"
  then error "Error: No edits detected."
       error "Aborting new milestone creation."
       rm "$NEW_MILESTONE_FILE"
       exit 1
  else echo
       echo "Milestone No. ${NEW_MILESTONE_NUM} created successfully"
       echo
  fi
}




function close_ticket_with_comment () {
# Usage: close_ticket_with_comment <ticket number>   # e.g. 23

  if   test ${#@} -ne 1
  then error "Error: Incorrect arguments provided to new_milestone function"
       echo
       display_usage
       exit 1
  fi

  cd $TICKETS_PATH

# This is the ticket file we're about to modify
  TICKET="${1%.ticket}.ticket"
  if   test -f "$TICKET"
  then :
  else echo "Error: Invalid ticket specified; file ${TICKET} does not exist!" && exit 1
  fi

# Save state of original ticket in case we need to revert at the end
  ORIGINAL_TICKET="$(cat $TICKET)"

# Get today's date
  TODAY=$(date +"%Y-%m-%d")

# Check that ticket is actually open
  grep "Status: Open" $TICKET > /dev/null
  if     test $? -eq 0
  then   :
  else   echo "Ticket No. $TICKET is not marked as Open! Please reopen if necessary." && exit
  fi

# Select an appropriate resolution
  echo "Closing ticket ${1} ($(grep -o "Summary: .*" "${TICKET}"))"
  echo
  echo "Select a resolution for this ticket:"
  declare -i REPLY   # The user's input is assigned to this variable; we want to ensure it only takes numeric values
  select RESOLUTION in "${TICKET_RESOLUTIONS[@]}"
  do
      if   test $REPLY -gt 0 && test $REPLY -le ${#TICKET_RESOLUTIONS[@]}
      then sed -i "s/Resolution: .*\$/Resolution: $RESOLUTION/" "${TICKET}"
           break
      else error "Invalid selection, please chose a number between 1 and ${#TICKET_RESOLUTIONS[@]}" && exit 1
      fi
  done
  declare +i REPLY

# Check if owner is set. If not, make me the owner.
  CURRENT_OWNER=$(grep -oP "(?<=Owner: ).*" "${TICKET}")
  WHOAMI=$(whoami)
  WHOAMI=${WHOAMI^}   # parameter expansion: make first character uppercase
  if test -z ${CURRENT_OWNER}   # If it's an empty string
  then
      sed -i "s/Owner: /Owner: $WHOAMI/" "${TICKET}"
      CURRENT_OWNER="$WHOAMI"
  fi

# Start a new comment:
  echo             >> "${TICKET}"
  echo             >> "${TICKET}"
  echo "== $TODAY" >> "${TICKET}"

# Leave empty line where the comment will go, and capture that line number
  echo >> "${TICKET}"
  LINENUM=$(cat "${TICKET}" | wc -l)

# Finalise ticket closing.
  echo "Closing ticket." >> "${TICKET}"

# If owner is different than closer, mention the closer's name in the closing comment explicitly
  if test "$CURRENT_OWNER" != "$WHOAMI"
  then
      echo "($WHOAMI)" >> "${TICKET}"
  fi

# Change status to Closed
  sed -i "s/Status: .*/Status: Closed/" "${TICKET}"

# Save current status of ticket before manual editing
  UNEDITED_TICKET="$(cat $TICKET)"

# Open default editor and put cursor in the right place for editing
  if   test $EDITOR == "vim"
  then vim  +"$LINENUM" "${TICKET}"
  else nano +"$LINENUM" "${TICKET}"
  fi

  EDITED_TICKET="$(cat $TICKET)"

  if   test "$UNEDITED_TICKET" = "$EDITED_TICKET"
  then error "Error: No edits detected."
       error "'Close' operation aborted and ticket reverted to original state."
       echo "$ORIGINAL_TICKET" > "$TICKET"
       exit 1
  fi
}




function add_comment_to_ticket () {
# Usage: add_comment_to_ticket <ticket number>   # e.g. 23

  if   test ${#@} -ne 1
  then error "Error: Incorrect arguments provided to add_comment_to_ticket function"
       echo
       display_usage
       exit 1
  fi

  cd $TICKETS_PATH

# This is the ticket file we're about to modify
  TICKET="${1%.ticket}.ticket"
  if test -f "$TICKET"
  then :
  else error "Error: Invalid ticket specified; file ${TICKET} does not exist!" && exit 1
  fi

# Save state of original ticket in case we need to revert at the end
  ORIGINAL_TICKET="$(cat $TICKET)"

# Get today's date
  TODAY=$(date +"%Y-%m-%d")

# Start a new comment:
  echo             >> "${TICKET}"
  echo             >> "${TICKET}"
  echo "== $TODAY" >> "${TICKET}"

# Leave empty line where the comment will go, and capture that line number
  echo >> "${TICKET}"
  LINENUM=$(cat "${TICKET}" | wc -l)

# If owner is different than closer, mention the closer's name in the closing comment explicitly
  if test "$CURRENT_OWNER" != "$WHOAMI"
  then
      echo "($WHOAMI)" >> "${TICKET}"
  fi

# Save current status of ticket before manual editing
  UNEDITED_TICKET="$(cat $TICKET)"

# Open default editor and put cursor in the right place for editing
  if   test $EDITOR == "vim"
  then vim  +"$LINENUM" "${TICKET}"
  else nano +"$LINENUM" "${TICKET}"
  fi

  EDITED_TICKET="$(cat $TICKET)"

  if   test "$UNEDITED_TICKET" = "$EDITED_TICKET"
  then error "Error: No edits detected."
       error "'Add comment' operation aborted and ticket reverted to original state."
       echo "$ORIGINAL_TICKET" > "$TICKET"
       exit 1
  fi
}




function assign_tickets_to_milestone () {

# If called without arguments, display usage
  if   test "$#" -le 1
  then display_usage 'assign_tickets_to_milestone'
       exit $EXIT_STATUS__INVALID_SUBCOMMAND_SYNTAX
  fi

  local ARGS=( "$@" )                               # Get all positional arguments as a bash array
  local MILESTONE_ARG="${ARGS[-1]}"                 # Get the last element of the array
  local TICKET_ARGS=( "${ARGS[@]: 0 : $# - 1 }" )   # Create a sub-array, from index 0 to N-1
  local MILESTONE_NO
  local TICKET_NO
  local TICKET_FILE

# Process Input Arguments
  ARGS=( "$@" )                               # Get all positional arguments as a bash array
  MILESTONE_ARG="${ARGS[-1]}"                 # Get the last element of the array
  TICKET_ARGS=( "${ARGS[@]: 0 : $# - 1 }" )   # Create a sub-array, from index 0 to N-1

# Confirm validity of inputs
  local ERRORS=0

  for  TICKET_ARG in "${TICKET_ARGS[@]}"
  do   if   is_valid_ticket "$TICKET_ARG"
       then :
       else ERRORS=$((ERRORS + 1))
       fi
  done

  if   is_valid_milestone "$MILESTONE_ARG"
  then :
  else ERRORS=$((ERRORS + 1))
  fi

  if test "$ERRORS" -gt 0
  then error "Encountered $ERRORS input errors. Aborting."
       exit 1
  fi

# Process all tickets
  MILESTONE_NO="${MILESTONE_ARG%.milestone}"   # Remove .milestone suffix
  MILESTONE_NO="${MILESTONE_NO%0}"             # If milestone was '0', use empty string instead.

  for  TICKET_ARG in "${TICKET_ARGS[@]}"
  do   TICKET_NO="${TICKET_ARG%.ticket}"
       TICKET_FILE="$TICKETS_PATH/${TICKET_NO}.ticket"
       sed -i "s/  Milestone: .*\$/  Milestone: ${MILESTONE_NO}/" "$TICKET_FILE"
  done

# update milestones accordingly - note, we need to update ALL milestones, because more than one may have changed
  update_milestones
}




function update_milestones () {

  local ARGS
  local MILESTONE_NO
  local MILESTONE_FILE
  local HEADER
  local ERRORS

# Process Input Arguments
  ARGS=( "$@" )   # Get all positional arguments as a bash array

  ERRORS=0

  if   test "${#ARGS[@]}" -eq 0                         # function was called without inputs

  then ARGS=( $MILESTONES_PATH/*.milestone )            # Collect all milestone filenames
       for  i in $( seq 0 "$(( ${#ARGS[@]} - 1))" )     # loop from index 0 to N-1
       do   ARGS["$i"]="${ARGS[$i]#$MILESTONES_PATH/}"  # Remove path prefix
            if   is_valid_milestone "${ARGS[$i]}"
            then :
            else ERRORS=$((ERRORS + 1))
            fi
       done

  else   # function was called with specific arguments

      for  ARG in "${ARGS[@]}"
      do   if   is_valid_milestone $ARG
           then :
           else ERRORS=$((ERRORS + 1))
           fi
      done
  fi

  if test "$ERRORS" -gt 0
  then echo "Encountered $ERRORS input errors. Aborting."
       exit 1
  fi

  for ARG in "${ARGS[@]}"
  do  MILESTONE_NO="${ARG%.milestone}"   # Remove .milestone suffix
      MILESTONE_FILE="$MILESTONES_PATH/${ARG%.milestone}.milestone"
      HEADER=$(grep --color=never "=== Open Tickets ===" "$MILESTONE_FILE" -n | cut -d: -f1 )

      head -n "+$HEADER" "$MILESTONE_FILE"              > "$MILESTONE_FILE.bak"
      echo                                             >> "$MILESTONE_FILE.bak"
      show_open_tickets_by_milestone "$MILESTONE_NO"   >> "$MILESTONE_FILE.bak"
      echo                                             >> "$MILESTONE_FILE.bak"
      echo "=== Closed Tickets ==="                    >> "$MILESTONE_FILE.bak"
      echo                                             >> "$MILESTONE_FILE.bak"
      show_closed_tickets_by_milestone "$MILESTONE_NO" >> "$MILESTONE_FILE.bak"
      mv "$MILESTONE_FILE.bak" "$MILESTONE_FILE"
  done
}




function show_open_tickets_by_milestone () {

# If called without arguments or with more than one arguments, display usage
  if   test "$#" -ne 1
  then display_usage "show_open_tickets_by_milestone"
       exit 1
  fi

  local MILESTONE="${1%.milestone}"

  if   test "$MILESTONE" = "0"
  then MILESTONE=""
  elif is_valid_milestone "$MILESTONE"
  then :
  else echo "Encountered input errors. Aborting."
       exit 1
  fi

  cd $TICKETS_PATH

  local MILESTONE_TICKETS=( $(egrep --color=never  -l "Milestone: $MILESTONE\$" *.ticket) )

  for  TICKET in "${MILESTONE_TICKETS[@]}"
  do   local TICKETNAME="$(grep -l --color=never "Status: Open" "$TICKET")"
       local TICKETSUMMARY="$(grep --color=never "Summary: " "$TICKET")"
       if test -n "$TICKETNAME"
       then echo "$TICKETNAME $TICKETSUMMARY"
       fi
  done
}




function show_closed_tickets_by_milestone () {

# If called without arguments or with more than one arguments, display usage
  if   test "$#" -ne 1
  then display_usage "show_closed_tickets_by_milestone"
       exit 1
  fi

  local MILESTONE="${1%.milestone}"

  if   test "$MILESTONE" = "0"
  then MILESTONE=""
  elif is_valid_milestone "$MILESTONE"
  then :
  else echo "Encountered input errors. Aborting."
       exit 1
  fi

  cd $TICKETS_PATH

  local MILESTONE_TICKETS=( $(egrep --color=never  -l "Milestone: $MILESTONE\$" *.ticket) )

  for  TICKET in "${MILESTONE_TICKETS[@]}"
  do   local TICKETNAME="$(grep -l --color=never "Status: Closed" "$TICKET")"
       local TICKETSUMMARY="$(grep --color=never "Summary: " "$TICKET")"
       if test -n "$TICKETNAME"
       then echo "$TICKETNAME $TICKETSUMMARY"
       fi
  done
}




#############
### Main body
#############

# -----------------------------
# Perform initial sanity checks
# -----------------------------

# Ensure we have a valid bashtickets installation
trycatch "check_bashtickets_installation" $EXIT_STATUS__INVALID_BASHTICKETS_INSTALLATION

# Ensure valid bashtickets repository for commands that require it
case "$1" in

    ( "init"   | "help"    | "h" )
        ;;   # do nothing for now


    ( "update"  | "up" | "show"   | "sh"     | "list"   | "ls" | "add"  | \
      "comment" | "a"  | "m"      | "assign" | "close"  | "cl" | "open" | \
      "reopen"  | "re" | "op"     | "new"    | "create" | "nt" | "ct"   | \
      "nm"      | "cm" | "status" | "st"     | "remove" | "rm" | "edit" | \
      "ed"  )

        trycatch "check_repo" \
                 $EXIT_STATUS__NOT_A_VALID_BASHTICKETS_REPOSITORY

        load_config
        ;;

    ( * )   ;;
esac


# ---------------------------
# Execute bashtickets command
# ---------------------------


case "$1" in
    ("init")                             trycatch "initialise_bashtickets_repository" $EXIT_STATUS__FAILED_TO_INITIALIZE_REPOSITORY ;;
    ("update" | "up")                    echo "Updating Milestones ...TODO" ;;
    ("show" | "sh" | "list" | "ls" )     echo "Showing tickets ...TODO" ;;
    ( "add" | "comment" | "a" | "m")     shift && trycatch "add_comment_to_ticket"       "$@" $EXIT_STATUS__FAILED_TO_ADD_COMMENT_TO_TICKET       ;;
    ("assign")                           shift && trycatch "assign_tickets_to_milestone" "$@" $EXIT_STATUS__FAILED_TO_ASSIGN_TICKETS_TO_MILESTONE ;;
    ("close" | "cl")                     shift && trycatch "close_ticket_with_comment"   "$@" $EXIT_STATUS__FAILED_TO_CLOSE_TICKET                ;;
    ("open" | "reopen" | "re" | "op" )   shift && trycatch "reopen_ticket"               "$@" $EXIT_STATUS__FAILED_TO_REOPEN_TICKET               ;;
    ("new" | "create" )                  shift && trycatch "new_ticket_or_milestone"     "$@" $EXIT_STATUS__FAILED_TO_CREATE_TICKET_OR_MILESTONE  ;;
    ("nt" | "ct" )                       shift && trycatch "new_ticket"                  "$@" $EXIT_STATUS__FAILED_TO_CREATE_TICKET               ;;
    ("nm" | "cm" )                       shift && trycatch "new_milestone"               "$@" $EXIT_STATUS__FAILED_TO_CREATE_MILESTONE            ;;
    ("help" | "h")                       display_help ;;
    ("status" | "st")                    echo "Displaying milestone status (all/open/closed)...TODO" ;;
    ("remove" | "rm")                    echo "Removing last ticket / milestone or by number...TODO" ;;
    ("edit" | "ed")                      echo "Edit ticket / milestone...TODO" ;;

  # Let's also include "fullname" subcommands ... this is mostly for testing. FIXME: REMOVE WHEN NO LONGER NEEDED
    ("show_open_tickets_by_milestone")   shift && trycatch show_open_tickets_by_milestone "$@" $EXIT_STATUS__OTHER_ERROR ;;
    ("show_closed_tickets_by_milestone") shift && trycatch show_closed_tickets_by_milestone "$@" $EXIT_STATUS__OTHER_ERROR ;;

    (*)                                  display_usage && exit $EXIT_STATUS__INVALID_SUBCOMMAND ;;
esac
