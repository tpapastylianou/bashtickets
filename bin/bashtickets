#!/bin/bash

################################################################################
###
### Bashtickets v0.0.1
###
### Contents:
###    • Script Constants
###    • Function definitions
###        • Helper functions
###            • Function: error
###            • Function: warning
###            • Function: is_in
###            • Function: process_optargs
###            • Function: trycatch
###            • Function: check_bashtickets_installation
###            • Function: is_valid_bashtickets_repository
###            • Function: check_repo
###            • Function: load_config
###            • Function: check_for_nocolor
###            • Function: display_usage
###            • Function: get_default_milestone_startdate
###            • Function: get_default_milestone_deadline
###            • Function: is_valid_ticket
###            • Function: is_valid_milestone
###            • Function: beg_for_money_lol
###            • Function: editor
###        • Functions implementing bashticket commands
###            • Function: create_or_initialise_bashtickets_repository
###            • Function: initialise_bashtickets_repository
###            • Function: create_bashtickets_repository
###            • Function: display_help
###            • Function: new_ticket_or_milestone
###            • Function: new_ticket
###            • Function: new_milestone
###            • Function: close_ticket_with_comment
###            • Function: add_comment_to_ticket
###            • Function: assign_tickets_to_milestone
###            • Function: update_milestones
###            • Function: show_tickets_by_milestone
###            • Function: show_open_tickets_by_milestone
###            • Function: show_closed_tickets_by_milestone
###            • Function: show_active_milestones
###            • Function: show_completed_milestones
###            • Function: edit_ticket
###            • Function: edit_milestone
###            • Function: edit_ticket_or_milestone
###            • Function: view_ticket_or_milestone
###            • Function: view_ticket
###            • Function: view_milestone
###        • Legacy functions
###            • Function: show_all_ticket_summaries
###            • Function: show_closed_ticket_resolutions
###            • Function: show_closed_ticket_summaries
###            • Function: show_open_ticket_summaries
###            • Function: show_open_ticket_summaries_by_owner
###            • Function: show_open_ticket_summaries_by_priority
###    • Main body
###        • Perform initial sanity checks
###        • Parse and execute bashtickets command
###
################################################################################

# - FIXME update above in due time



####################
### Script constants
####################

 # Declare directories where relevant bashticket files should reside
   BT_BIN_DIR="$(dirname "$BASH_SOURCE" | xargs realpath)"
   BT_ROOT_DIR="${BT_BIN_DIR%"/bin"}"
   BT_BIN_DIR="${BT_ROOT_DIR/bin}"
   BT_SHARE_DIR="$BT_ROOT_DIR/share/bashtickets"
   BT_DOC_DIR="$BT_SHARE_DIR/doc"

   TICKET_TEMPLATE="$BT_DOC_DIR/ticket.template"
   MILESTONE_TEMPLATE="$BT_DOC_DIR/milestone.template"

 # Assuming a valid repo, the following paths should exist
   REPO_PATH="$( realpath . )"
   TICKETS_PATH="$REPO_PATH/tickets"
   MILESTONES_PATH="$REPO_PATH/milestones"

 # Other constants
   ANSI_RED="\x1b[91m"
   ANSI_GREEN="\x1b[92m"
   ANSI_PURPLE="\x1b[95m"
   ANSI_YELLOW="\x1b[93m"
   ANSI_BLUE="\x1b[94m"
   ANSI_BOLD_ON="\x1b[1m"
   ANSI_BOLD_OFF="\x1b[22m"
   ANSI_RESET="\x1b[39m"


 # Declare exit statuses for various errors
   declare -i EXIT_STATUS__INVALID_BASHTICKETS_INSTALLATION=2
   declare -i EXIT_STATUS__NOT_A_VALID_BASHTICKETS_REPOSITORY=3
   declare -i EXIT_STATUS__FAILED_TO_INITIALIZE_REPOSITORY=4
   declare -i EXIT_STATUS__FAILED_TO_CREATE_TICKET_OR_MILESTONE=5
   declare -i EXIT_STATUS__FAILED_TO_CREATE_TICKET=6
   declare -i EXIT_STATUS__FAILED_TO_CREATE_MILESTONE=7
   declare -i EXIT_STATUS__FAILED_TO_CLOSE_TICKET=8
   declare -i EXIT_STATUS__FAILED_TO_REOPEN_TICKET=9
   declare -i EXIT_STATUS__FAILED_TO_ADD_COMMENT_TO_TICKET=10
   declare -i EXIT_STATUS__FAILED_TO_ASSIGN_TICKETS_TO_MILESTONE=11
   declare -i EXIT_STATUS__FAILED_TO_EDIT_TICKET_OR_MILESTONE=12
   declare -i EXIT_STATUS__FAILED_TO_EDIT_TICKET=13
   declare -i EXIT_STATUS__FAILED_TO_EDIT_MILESTONE=14
   declare -i EXIT_STATUS__FAILED_TO_CREATE_NEW_REPOSITORY=15
   declare -i EXIT_STATUS__FAILED_TO_CREATE_OR_INITIALIZE_REPOSITORY=16
   declare -i EXIT_STATUS__FAILED_TO_LIST_TICKETS_OR_MILESTONES=17

   declare -i EXIT_STATUS__INVALID_SUBCOMMAND=100
   declare -i EXIT_STATUS__INVALID_SUBCOMMAND_SYNTAX=101
   declare -i EXIT_STATUS__OTHER_ERROR=102   # in theory this should never happen



########################
### Function definitions
########################

 # ----------------
 # Helper functions
 # ----------------

   function error () {
    # --------------------------------------------------------------------------
    # A useful, 'libstderred.so' compatible function for safely echoing error
    # messages to stderr (see: https://unix.stackexchange.com/a/164223)
    # --------------------------------------------------------------------------

      awk "BEGIN { print \"$*\" > \"/dev/stderr\" }"
   }




   function warning () {
    # ------------------------------------
    # Same as `error`, but printed in blue
    # ------------------------------------

      error "${ANSI_BLUE}$*${ANSI_RESET}"
   }




   function is_in () {
    # --------------------------------------------------------------------------
    # Checks if first input reoccurs in the remaining list of input arguments.
    #
    # The intended way to call this function is with an 'exploded' array
    # variable as the second argument, effectively checking if the first input
    # is a member of the array, e.g.:
    #
    #   Elements=( 1 3 5 7 9 )
    #   is_in 5 "${Elements[@]}"   # succeeds
    #   is_in 6 "${Elements[@]}"   # fails
    # --------------------------------------------------------------------------

      Element="$1" && shift
      for Arg; do test "$Element" = "$Arg" && return 0; done
      return 1
   }




   function process_optargs () {
    # -------------------------------------------------------------------------
    # Used inside a (caller) function to parse its input arguments into
    # arguments and options.
    #
    # The intended way to call it is with "$@" as the argument, which
    # effectively passes the caller function's input arguments down to this
    # function for processing.
    #
    # This function expects the OPTIONS and ARGS variables to be defined in the
    # caller function as a local associative array and local indexed array
    # respectively. These will be populated with options and arguments
    # respectively.
    #
    # For the function to work properly, the caller function must also define
    # the following local variables:
    #  • The variable COMMAND_NAME, specifying the name of the caller function
    #  • The following string arrays:
    #    • VALID_SHORT_FLAG_OPTIONS
    #    • VALID_LONG_FLAG_OPTIONS
    #    • VALID_SHORT_KEYVAL_OPTIONS
    #    • VALID_LONG_KEYVAL_OPTIONS
    #
    # These are only inspected for validation purposes, and will not be
    # modified in the caller function.
    #
    # The individual string elements in the 'keyval' arrays must correspond to
    # the same option for the same index, as this is used to check that
    # equivalent short and long keyval options have not been used
    # simultaneously.
    #
    # The 'flag' arrays do not undergo such a check since there is no
    # possibility of conflict from simultaneous use, so strictly speaking there
    # is no need to arrange the two arrays in the same order; however, it is
    # still advised to do so for the sake of symmetry.
    # -------------------------------------------------------------------------

    # Helper local functions
      local OPTION_KEY    # Holds a 'key' string when populating the OPTIONS associative array with an option token
      local OPTION_VALUE  # Holds a 'value' when populating the OPTIONS associative array with an option token
      local OPTION_SHIFT  # Used to remove the appropriate number of tokens from the list of input arguments, after an option has been processed.
      local STILL_PROCESSING_OPTIONS=true   # Turned 'off' when '--' is passed as an argument

      while test ${#@} -gt 0
      do
          # Stop processing options if given '--' by itself
            if   test "$1" = "--"
            then STILL_PROCESSING_OPTIONS=false
                 shift && continue

          # Process flag option in long form if valid
            elif $STILL_PROCESSING_OPTIONS &&
                 test "${1:0:2}" = "--"   &&
                 is_in "$1" "${VALID_LONG_FLAG_OPTIONS[@]}"
            then OPTION_KEY="$1"; OPTION_VALUE="On"; OPTION_SHIFT=1

          # Process key-value option in long form if valid
            elif $STILL_PROCESSING_OPTIONS &&
                 test "${1:0:2}" = "--"   &&
                 is_in "${1%=*}" "${VALID_LONG_KEYVAL_OPTIONS[@]}"
            then if   test "$( echo "$1" | tr -s [:alpha:] Y )" = "--Y"                # check if first token is of form '--optionname'
                 then OPTION_KEY="$1"; OPTION_VALUE="$2"; OPTION_SHIFT=2
                 elif test "$( echo "$1" | tr -s [:alpha:] Y | cut -b -4 )" = "--Y="   # check if first token is of form '--optionname='
                 then OPTION_KEY="$(   echo "$1" | cut -d= -f1 )"
                      OPTION_VALUE="$( echo "$1" | cut -d= -f2 )"
                      OPTION_SHIFT=1
                 else error "Error: '$1' seems not to be a valid first token for a long form key value option?"
                 fi

          # If a long-form option is detected but is not valid, raise an error
            elif $STILL_PROCESSING_OPTIONS &&
                 test "${1:0:2}" = "--"
            then error "Error: Unknown option '${1%=*}' passed to $COMMAND_NAME" && return 1

          # Process key-value option in short form if valid
            elif $STILL_PROCESSING_OPTIONS &&
                 test "${1:0:1}" = "-"    &&
                 is_in "${1:0:2}" "${VALID_SHORT_KEYVAL_OPTIONS[@]}"
            then if   test ${#1} -eq 2   # Check if option key is contiguous with value or not and assign accordingly
                 then OPTION_KEY="$1"      ; OPTION_VALUE="$2"    ; OPTION_SHIFT=2
                 else OPTION_KEY="${1:0:2}"; OPTION_VALUE="${1:2}"; OPTION_SHIFT=1
                 fi

          # Process flag option in short form if valid
            elif $STILL_PROCESSING_OPTIONS &&
                 test "${1:0:1}" = "-"    &&
                 test ${#1} -eq 2         &&
                 is_in "$1" "${VALID_SHORT_FLAG_OPTIONS[@]}"
            then OPTION_KEY="$1"; OPTION_VALUE="On"; OPTION_SHIFT=1

          # If concatenated short-form flags are detected, split and reprocess
            elif $STILL_PROCESSING_OPTIONS &&
                 test "${1:0:1}" = "-"    &&
                 is_in "-${1:1:1}" "${VALID_SHORT_FLAG_OPTIONS[@]}"
            then set -- "${1:0:2}" "-${1:2}" "${@:2}"   # split joined flags
                 continue

          # If a short-form option is detected but is not valid, raise an error
            elif $STILL_PROCESSING_OPTIONS &&
                 test "${1:0:1}" = "-"    &&
                 test ${#1} -gt 1
            then error "Error: Unknown option '${1:0:2}' passed to $COMMAND_NAME" && return 1

          # All option scenarios covered; process next token as a normal argument.
            else ARGS[${#ARGS[@]}]="$1"   # i.e. append at end of ARGS array
                 shift && continue
            fi


          # If we're here it means an option has been processed
            OPTIONS["$OPTION_KEY"]="$OPTION_VALUE"
            shift $OPTION_SHIFT
      done


    # Confirm that there are is no simultaneous use of equivalent short/long
    # keyval options
      local -i i
      local SHORT_OPT
      local LONG_OPT
      local -a KEYS=( "${!OPTIONS[@]}" )
      for (( i=0 ; i<${#KEYS[@]} ; i++ ))
      do
           SHORT_OPT="${VALID_SHORT_KEYVAL_OPTIONS[$i]}"
           LONG_OPT="${VALID_LONG_KEYVAL_OPTIONS[$i]}"
           if   is_in "$SHORT_OPT" "${KEYS[@]}" && is_in "$LONG_OPT" "${KEYS[@]}"
           then error "Error: Cannot provide both '$SHORT_OPT' and '$LONG_OPT' options at the same time!" && return 1
           fi
      done


    # By this points the OPTIONS and ARGS arrays have been populated
    # and will be accessed by the parent function after this one returns.

   }




   function trycatch () {
    # ------------------------------------------------
    # Run command, exit gracefully in case of failure.
    # ------------------------------------------------

      local COMMAND=( "${@: 1: ${#@} - 1}" )   # Collect all input arguments
                                               # except last, as an array

      local -i EXITSTATUS="${@: -1}"   # Get last input argument only (as integer)

      if   "${COMMAND[@]}"   # Run the respective command with accompanying
                             # arguments, and check its exit status

      then :

      else exit $EXITSTATUS   # If the above command exited with non-zero status,
                              # abort this script with the exit status provided as
                              # the last input argument to this function
      fi
   }




   function check_bashtickets_installation () {
    # --------------------------------------------------------------------------
    # Assert everything is installed in the expected locations (relative to this
    # script)
    # --------------------------------------------------------------------------

       if     test -d "$BT_ROOT_DIR"      &&
              test -d "$BT_BIN_DIR"       &&
              test -d "$BT_SHARE_DIR"     &&
              test -d "$BT_DOC_DIR"

       then   :   # i.e. do nothing

       else   error "Error: Did not detect a valid installation of bashtickets."
              error "       Please re-install and try again."
              return 1
       fi
   }




   function is_valid_bashtickets_repository () {
    # --------------------------------------------------------------------------
    # In order for a directory to be a valid 'bashtickets repository', it needs
    # to contain a directory called '.bashtickets'; this directory should then
    # contain a file called "config", which should be sourceable without errors.
    # Furthermore, it should contain a directory called 'tickets', and a
    # directory called 'milestones'.
    # --------------------------------------------------------------------------

    # Check for the presence of a '.bashtickets' directory
      if   test -d ./.bashtickets
      then :
      else error "Error: Not a valid bashtickets repository ('.bashtickets' directory missing)"
           return 1
      fi

    # Check for the presence of a valid config file
      if   test -f ./.bashtickets/config
      then :
      else error "Error: Not a valid bashtickets repository ('.bashtickets/config' file missing)"
           return 1
      fi

    # Check if the config file can be sourced without errors
      ( set -e; source ./.bashtickets/config )
      if   test $? -eq 0
      then :
      else error "Error: Not a valid bashtickets repository (errors found in '.bashtickets/config' file)"
           return 1
      fi

    # Check for the presence of a 'tickets' directory
      if   test -d ./tickets
      then :
      else error "Error: Not a valid bashtickets repository ('tickets' directory missing)"
           return 1
      fi

    # Check for the presence of a 'milestones' directory
      if   test -d ./milestones
      then :
      else error "Error: Not a valid bashtickets repository ('milestones' directory missing)"
           return 1
      fi

    # If all tests passed successfully, return normally.
      return 0
   }




   function check_repo () {
    # ------------------------------
    # (a simple convenience wrapper)
    # ------------------------------

      trycatch "is_valid_bashtickets_repository" \
               $EXIT_STATUS__NOT_A_VALID_BASHTICKETS_REPOSITORY
   }




   function load_config () {
    # --------------------------------------------------------------------------
    # Import all the contents of the config file into the current environment.
    #
    # This function is run quite late into the main script, meaning that any
    # variables or functions defined in the main script that are also defined in
    # the config file, will be overriden by the definitions in the config file.
    #
    # This serves as a mechanism to allow users to override default
    # functionality in individual repositories as needed, without having to
    # tamper with their system-wide 'bashtickets' installation.
    # --------------------------------------------------------------------------

      declare -g CONFIG_FILE="$( realpath ./.bashtickets/config )"
      source "$CONFIG_FILE"
   }




   function check_for_nocolor () {
    # --------------------------------------------------------------------------
    # This function checks for the presence of the NO_COLOR variable, as per
    # https://no-color.org/. If it is non-empty, it resets all ansi-color
    # variables used for colorization in this script.
    #
    # The NO_COLOR variable may either be set as an environmental variable, or
    # in the repo's config file.
    # --------------------------------------------------------------------------

      if   test -n "$NO_COLOR"
      then ANSI_RED=
           ANSI_GREEN=
           ANSI_PURPLE=
           ANSI_YELLOW=
           ANSI_BLUE=
           ANSI_BOLD_ON=
           ANSI_BOLD_OFF=
           ANSI_RESET=
      fi
   }




   function display_usage () {
    # --------------------------------------------------------------------------
    # This function will need to display appropriate usage for the bashtickets
    # main program, AS WELL AS for the relevant subcommands (threfore it will
    # require processing of an input argument).
    # --------------------------------------------------------------------------

      ### TODO - confirm all usage strings are up to date in due time.

      case $1 in

          ('bashtickets')
              echo "Usage: bashtickets ... TODO"
              ;;

          ('initialise_bashtickets_repository')
              echo "Usage: initialise_bashtickets_repository ... TODO"
              ;;

          ('assign_tickets_to_milestone')
              echo "Usage:"
              echo "    $(basename $0) assign <ticket> [<ticket2> <ticket3> ... <ticketN>] <milestone>"
              echo
              echo "e.g.:"
              echo "    $(basename $BASH_SOURCE) assign 1.ticket 2.ticket 1.milestone"
              echo
              echo "or simply:"
              echo "    $(basename $BASH_SOURCE) 1 2 1"
              echo
              echo "Using '0' as the milestone removes any existing milestones from the specified tickets instead"
              ;;

          ('update_milestones')
              echo "Usage:"
              echo
              echo "    $(basename $0) [milestone1 milestone2 ... milestoneN]"
              echo
              echo "Updates all or specific milestones from tickets"
              echo
              echo "e.g.:"
              echo "    $(basename $0) 001.milestone   # update milestone 001 only"
              echo "    $(basename $0) 001             # short version of above"
              echo "    $(basename $0) 001 002 003     # update milestones 001 002 and 003 only"
              echo "    $(basename $0)                 # update all milestones"
              ;;

          ('show_open_tickets_by_milestone')
              echo "Usage:"
              echo "    $(basename $0) <milestone>"
              echo
              echo "e.g.:"
              echo "    $(basename $0) 001.milestone"
              echo
              echo "or simply:"
              echo "    $(basename $0) 001"
              echo
              echo "Note: Using '0' as the milestone displays tickets that are not assigned to any milestones"
              ;;

          ('show_closed_tickets_by_milestone')
              echo "Usage:"
              echo "    $(basename $0) <milestone>"
              echo
              echo "e.g.:"
              echo "    $(basename $0) 001.milestone"
              echo
              echo "or simply:"
              echo "    $(basename $0) 001"
              echo
              echo "Note: Using '0' as the milestone displays tickets that are not assigned to any milestones"
              ;;

          ('editor')
              echo "Usage:"
              echo "   $(basename $0) <filename> <line number> <column number>"
              echo
              echo "Note: All three fields are mandatory."
              echo "      Lines and columns are numbered starting from '1'."
              ;;

          (*)
              echo "Displaying default usage for '$1' ... TODO";
              ;;
      esac
   }



   function get_default_milestone_startdate () {
    # -----------------------------------------------------
    # Default functionality here is to return today's date.
    # Can be overriden in the config if desired
    # -----------------------------------------------------

      date +"%Y-%m-%d"   # i.e. today's date
   }




   function get_default_milestone_deadline () {
    # --------------------------------------------------------------------------
    # Default functionality here is to return the date corresponding to a month
    # after the date given as an argument.
    #
    # Can be overridden in the config if desired
    # --------------------------------------------------------------------------

      local STARTDATE="$1"

      date --date="$STARTDATE +1 month" +"%Y-%m-%d"
   }




   function is_valid_ticket () {
    # --------------------------------------------------------------------------
    # The check performed here is very basic; it only checks if the filename
    # exists in the first place, and if so, whether it the first line starts
    # with the string ' Ticket No.: ' (note the spaces!).
    # --------------------------------------------------------------------------

      local TICKET="${1%.ticket}.ticket"

    # Test if ticket file exists in the first place
      if   test -f "$TICKETS_PATH/$TICKET"
      then :
      else warning "Warning: ticket '$TICKET' does not exist in '$TICKETS_PATH'."
           return 1
      fi

    # Test if ticket file is of valid form
      if   head "$TICKETS_PATH/$TICKET" -n +1 | egrep "^ Ticket No.: " > /dev/null
      then :
      else warning "Warning: file '$TICKET' does not appear to be of valid ticket syntax"
           warning "         (line 1 should start with: ' Ticket No.: ')"
           return 1
      fi
   }




   function is_valid_milestone () {
    # --------------------------------------------------------------------------
    # The check performed here is very basic; it only checks if the filename
    # exists in the first place, and if so, whether it the first line starts
    # with the string 'Milestone No.: ' (note the spaces!).
    # --------------------------------------------------------------------------

      local MILESTONE="${1%.milestone}.milestone"

    # Test if milestone file exists in the first place
      if   test -f "$MILESTONES_PATH/$MILESTONE"
      then :
      else warning "Warning: milestone '$MILESTONE' does not exist in '$MILESTONES_PATH'."
           return 1
      fi

    # Test if milestone file is of valid form
      if   head "$MILESTONES_PATH/$MILESTONE" -n +1 | egrep "^Milestone No.: " > /dev/null
      then :
      else warning "Warning: file '$MILESTONE' does not appear to be of valid milestone syntax"
           warning "         (line 1 should start with: 'Milestone No.: ')"
           return 1
      fi
   }




   function beg_for_money_lol () {
      local MSG='!!! Congratulations on your 100th ticket !!!'
      local MSG_LEN=$(( $( echo $MSG | wc -m ) -1 ))
      local LEFTPAD=$(( COLUMNS / 2 - MSG_LEN / 2 ))
      local BANNER_LEN=$(( 4 + MSG_LEN + 4 ))
      local BANNER="$( yes '*' | head -n +$BANNER_LEN | paste -s -d '' )"
      echo
      echo
      printf "%${LEFTPAD}s${ANSI_BLUE}$BANNER${ANSI_RESET}\n" ""
      printf "%${LEFTPAD}s${ANSI_BLUE}*** %${MSG_LEN}s ***${ANSI_RESET}\n" "" ""
      printf "%${LEFTPAD}s${ANSI_BLUE}*** ${ANSI_GREEN}${ANSI_BOLD_ON}$MSG ${ANSI_BOLD_OFF}${ANSI_BLUE}***${ANSI_RESET}\n" ""
      printf "%${LEFTPAD}s${ANSI_BLUE}*** %${MSG_LEN}s ***${ANSI_RESET}\n" "" ""
      printf "%${LEFTPAD}s${ANSI_BLUE}$BANNER${ANSI_RESET}\n" ""
      echo -e "${ANSI_YELLOW}"
      printf "%${LEFTPAD}sIf you feel that bashtickets have helped you, then\n" ""
      printf "%${LEFTPAD}sI'm hoping that perhaps you might consider \"buying\n"  ""
      printf "%${LEFTPAD}sme a cup of coffee\"? :)\n"                         ""
      echo
      printf "%${LEFTPAD}sIf so, you can do so here: http://tpapastylianou.com/donate\n" ""
      echo
      printf "%${LEFTPAD}sThank you for using bashtickets!\n"
      echo -e "${ANSI_RESET}"
      echo
      echo
      echo "(Note: This banner only triggers once per bashtickets repository; however if you'd like to disable it altogether, feel free to do so by commenting out the last four lines of the 'new_ticket' function in the main '/bin/bashtickets' script)"
   }




   function editor () {
    # --------------------------------------------------------------------------
    # The default function here checks the EDITOR environment variable; if it is
    # 'vim', it launches the vim editor at the given line and column. Otherwise
    # it launches nano instead.
    #
    # This function may be overriden in the config.
    # The EDITOR variable may also be defined in the config.
    # --------------------------------------------------------------------------

      if   test $# -eq 3
      then :
      else error "Error: incorrect number of arguments used."
           display_usage editor
           return 1
      fi

      local FILE="$1"
      local LINE="$2"
      local COLUMN="$3"

      if   test $EDITOR = "vim"
      then vim "+cal cursor($LINE,$COLUMN)" "$FILE"
      else nano +$LINE,$COLUMN "$FILE"
      fi
   }



 # ------------------------------------------
 # Functions implementing bashticket commands
 # ------------------------------------------

   function create_or_initialise_bashtickets_repository () {
    # --------------------------------------------------------------------------
    # Invoked via the 'init' subcommand
    #
    # Delegates to 'initialise_bashtickets_repository' or to
    # 'create_bashtickets_repository', depending on whether it has been passed
    # an argument or not.
    # --------------------------------------------------------------------------

      if   test ${#@} -eq 0   # called with no arguments

      then if   initialise_bashtickets_repository
           then :
           else exit $EXIT_STATUS__FAILED_TO_INITIALIZE_REPOSITORY
           fi

      elif test ${#@} -eq 1   # called with one argument

      then if   create_bashtickets_repository "$1"
           then :
           else exit $EXIT_STATUS__FAILED_TO_CREATE_NEW_REPOSITORY
           fi

      else error "Error: Invalid number of arguments passed to 'init' subcommand."
           display_usage init
           exit $EXIT_STATUS__INVALID_SUBCOMMAND_SYNTAX

      fi
   }




   function initialise_bashtickets_repository () {
    # --------------------------------------------------------------------------
    # Invoked via the 'init' subcommand, when called without arguments.
    #
    # Creates the following tree in the current directory:
    #
    #   .
    #   ├── .bashtickets
    #   │   └── config
    #   ├── milestones
    #   └── tickets
    #
    # The default config file used is the sample_config file found in the
    # 'share/doc' directory from the bashtickets installation folder.
    # --------------------------------------------------------------------------

    # Desired case: Empty directory detected
      if   test $( ls -A | wc -l ) -eq 0   # empty directory detected

      then if     mkdir .bashtickets
           then   :
           else   error "Error: Could not create a '.bashtickets' subdirectory in the current directory."
                  error "       Please ensure you have the necessary permissions."
                  return 1
           fi


           if   cp  "$BT_DOC_DIR/sample_config" ".bashtickets/config"
           then :
           else   error "Error: Could not create a 'config' file in the '.bashtickets' subdirectory."
                  error "       Please ensure you have the necessary permissions."
                  return 1
           fi


           if     mkdir tickets
           then   :
           else   error "Error: Could not create 'tickets' directory."
                  return 1
           fi


           if     mkdir milestones
           then   :
           else   error "Error: Could not create 'milestones' directory."
                  return 1
           fi

           echo   "Bashtickets repository initialised successfully."


      elif is_valid_bashtickets_repository 2> /dev/null

      then error "Error: Current directory is already a valid bashtickets repository"
           error "       Aborting..."
           return 1

      else error "Error: Non-empty directory detected."
           error "       To initialise as a bashtickets repository, please delete all files"
           error "       (including hidden files) and try again."
           return 1

      fi
   }




   function create_bashtickets_repository () {
    # --------------------------------------------------------------------------
    # Invoked via 'init' subcommand, when passed an argument.
    #
    # Expects a single argument corresponding to the name of the repository to
    # be created.
    #
    # This function creates a new directory and proceeds to initialise it as a
    # bashtickets repository; if a folder by that name already exists, or a new
    # directory cannot be created, the process is aborted.
    # --------------------------------------------------------------------------

    # Attempt to create a new directory.
      if   mkdir "$1"
      then :
      else error "Error: unable to create a new '$1' directory at $(realpath .). Aborting."
           return 1
      fi

    # Initialise the newly created directory
      cd "$1"
      initialise_bashtickets_repository > /dev/null
      echo "Bashtickets repository '$1' created successfully."
   }




   function display_help  () {
    # ----------------------------------
    # Invoked via the 'help' subcommand.
    # ----------------------------------

      ### TODO - confirm all help strings are up to date in due time.

      case $1 in

          ('bashtickets')
              echo "Help: bashtickets ... TODO"
              ;;

          (*)
              echo "Displaying default help ... TODO";
              ;;


      esac
   }




   function new_ticket_or_milestone () {
    # --------------------------------------------------------------------------
    # Invoked via the 'new' subcommand.
    #
    # Expects to be called as either 'new ticket' or 'new milestone', and
    # delegates to the 'new_ticket' or 'new_milestone' functions as appropriate,
    # passing all remaining arguments given during invocation.
    # --------------------------------------------------------------------------

      case "$1" in
          ("ticket")     shift && new_ticket    "$@" ;;
          ("milestone")  shift && new_milestone "$@" ;;
          (*)            error "Error: Invalid argument given to 'new'."
                         error "       Valid arguments are 'ticket' or 'milestone'."
                         return 1 ;;
      esac
   }




   function new_ticket () {
    # --------------------------------------------------------------------------
    # Invoked via the 'nt' or 'new ticket' subcommands.
    # An '-m / --milestone' option can be used to assign a parent milestone.
    #
    # This function uses menus to select appropriate choices to fill in the
    # ticket, creates the ticket from a template and copies those choices in,
    # and then opens an editor to allow the user to finish editing the ticket.
    #
    # If no edits are made, the ticket is cancelled.
    #
    # The various menu choices are defined via standard bash arrays in the
    # config file, and can therefore be overriden by the user.
    # --------------------------------------------------------------------------

      local PARENT_MILESTONE
      local PARENT_MILESTONE_NUM
      local PARENT_MILESTONE_FILE
      local LAST_TICKET_NUM
      local NEW_TICKET_NUM
      local NEW_TICKET_FILE
      local TEMP_FILE
      local UNEDITED_TICKET
      local EDITED_TICKET


    # Process input arguments
      local -A OPTIONS
      local -a ARGS
      local VALID_SHORT_FLAG_OPTIONS=( )
      local VALID_LONG_FLAG_OPTIONS=( )
      local VALID_SHORT_KEYVAL_OPTIONS=( -m      )
      local VALID_LONG_KEYVAL_OPTIONS=( --milestone )
      local COMMAND_NAME="new_ticket"

      if   process_optargs "$@"
      then :
      else exit $EXIT_STATUS__INVALID_SUBCOMMAND_SYNTAX
      fi


    # Validate input arguments
      if   is_in '-m' "${!OPTIONS[@]}" && is_in '--milestone' "${!OPTIONS[@]}"
      then error "Error: Cannot provide both '-m' and '--milestone' at the same time!"
           echo && display_usage
           exit $EXIT_STATUS__INVALID_SUBCOMMAND_SYNTAX
      elif is_in '-m' "${!OPTIONS[@]}"
      then PARENT_MILESTONE="${OPTIONS[-m]}"
      elif is_in '--milestone' "${!OPTIONS[@]}"
      then PARENT_MILESTONE="${OPTIONS[--milestone]}"
      fi

      if   test ${#ARGS[@]} -eq 0   # no arguments provided
      then :
      else error "Error: Incorrect arguments provided to new_ticket function"
           echo && display_usage
           exit $EXIT_STATUS__INVALID_SUBCOMMAND_SYNTAX
      fi


      cd "$TICKETS_PATH"


    # If a parent milestone has been specified, check that this is valid
    # before proceeding

      if   test -n "$PARENT_MILESTONE"
      then PARENT_MILESTONE_FILE="${PARENT_MILESTONE%.milestone}.milestone"
           if   is_valid_milestone "$PARENT_MILESTONE"
           then PARENT_MILESTONE_NUM="${PARENT_MILESTONE_FILE%.milestone}"
           else error "Error: The specified parent milestone ('$PARENT_MILESTONE_FILE') does not exist in $MILESTONES_PATH. Aborting."
                return 1
           fi
      fi


    # If this is the first ticket, start numbering from 1; otherwise, find the
    # highest ticket number, and increment by one.

      if     test -f 1.ticket
      then   LAST_TICKET_NUM=$(ls *.ticket | sort -n | tail -n -1)   # list files, sort in numerical (not alphabetical) order, and keep last filename
             LAST_TICKET_NUM=${LAST_TICKET_NUM%.ticket}   # parameter expansion: remove '.ticket' suffix
             NEW_TICKET_NUM=$(( $LAST_TICKET_NUM + 1 ))
      else   NEW_TICKET_NUM=1
      fi

      TEMP_FILE="$(tempfile).ticket"
      NEW_TICKET_FILE="${NEW_TICKET_NUM}.ticket"


    # Create a new ticket from template
      cp "$TICKET_TEMPLATE" "${TEMP_FILE}"

    # Update ticket number
      sed -i "s/Ticket No.: /Ticket No.: ${NEW_TICKET_NUM}/" "${TEMP_FILE}"

    # Try to set owner and reporter automatically:
      WHOAMI=$(whoami)
      WHOAMI=${WHOAMI^}   # parameter expansion: make first character uppercase
      sed -i "s/Reporter: /Reporter: $WHOAMI/" "${TEMP_FILE}"
      sed -i "s/Owner: /Owner: $WHOAMI/" "${TEMP_FILE}"

    # Select a valid type:
      echo "Select a valid ticket type:"
      declare -i REPLY   # The user's input is assigned to this variable; we want to ensure it only takes numeric values
      select TICKET_TYPE in "${TICKET_TYPES[@]}"   # TICKET_TYPES obtained from config
      do
          if   test $REPLY -gt 0 && test $REPLY -le ${#TICKET_TYPES[@]}
          then sed -i "s/Type: /Type: $TICKET_TYPE/" "${TEMP_FILE}"
               break
          else error "Error: Invalid selection, please chose a number between 1 and ${#TICKET_TYPES[@]}" && return 1
          fi
      done
      declare +i REPLY

    # Select a valid priority:
      echo
      echo "Select a valid ticket priority"
      declare -i REPLY   # The user's input is assigned to this variable; we want to ensure it only takes numeric values
      select TICKET_PRIORITY in "${TICKET_PRIORITY_LEVELS[@]}"   # TICKET_PRIORITY_LEVELS obtained from config
      do
          if   test $REPLY -gt 0 && test $REPLY -le ${#TICKET_PRIORITY_LEVELS[@]}
          then sed -i "s/Priority: /Priority: ${TICKET_PRIORITY%% *}/" "${TEMP_FILE}"   # Remove everything in the priority string after the first space (i.e. the explanation of the priority level)
               break
          else error "Error: Invalid selection, please chose a number between 1 and ${#TICKET_PRIORITY_LEVELS[@]}" && return 1
          fi
      done
      declare +i REPLY

    # Set the provided parent milestone, if one was provided
      sed -i "s/Milestone: /Milestone: $PARENT_MILESTONE_NUM/" "${TEMP_FILE}"

    # Set today's date
      TODAY=$(date +"%Y-%m-%d")
      sed -i "s/Date: /Date: $TODAY/" "${TEMP_FILE}"

    # Mark the ticket as Open
      sed -i "s/Open\/Closed: /Open\/Closed: Open/" "${TEMP_FILE}"

    # Set ticket status to 'New' (or, more specifically, the *first* element of
    # the TICKET_STATUSES array in the config.
      sed -i "s/Status: /Status: ${TICKET_STATUSES[0]}/" "${TEMP_FILE}"

    # Save current state of ticket before manual editing
      UNEDITED_TICKET="$(cat "$TEMP_FILE")"


    # Open the resulting file for editing (see 'editor' function), placing the
    # cursor at the Summary field.

      editor "${TEMP_FILE}" 2 14

      EDITED_TICKET="$(cat "$TEMP_FILE")"

      if   test "$UNEDITED_TICKET" = "$EDITED_TICKET"
      then error "Error: No edits detected."
           error "       Aborting new ticket creation."
           rm "$TEMP_FILE"
           return 1
      else if   cp "$TEMP_FILE" "$NEW_TICKET_FILE"
           then :
           else error "Error: could not copy temporary ticket file to $TICKETS_PATH"
                return 1
           fi
           echo
           echo "Ticket No. ${NEW_TICKET_NUM} created successfully"
           echo
      fi

    # Let's also update the relevant milestone
      if   test -n "$PARENT_MILESTONE"
      then update_milestones $PARENT_MILESTONE_NUM
      fi

    # If this was the 100th ticket, ask for some dev appreciation :)))
      if   test $NEW_TICKET_NUM -eq 100
      then beg_for_money_lol
      fi
   }




   function new_milestone () {
    # --------------------------------------------------------------------------
    # Invoked via the 'nm' or 'new milestone' subcommands.
    # A '-p / --parent' option can be used to assign a parent milestone.
    #
    # This function creates the milestone from a template and then opens an
    # editor to allow the user to finish editing the milestone.
    #
    # If no edits are made, the milestone is cancelled.
    #
    # The function relies on the 'get_default_milestone_startdate' and
    # 'get_default_milestone_deadline' functions to set start and end dates for
    # the milestone; these functions can be overriden in the config.
    # --------------------------------------------------------------------------

      local PARENT_MILESTONE
      local PARENT_MILESTONE_NUM
      local PARENT_MILESTONE_FILE
      local LAST_MILESTONE_NUM
      local NEW_MILESTONE_NUM
      local NEW_MILESTONE_FILE
      local TEMP_FILE
      local DEFAULT_STARTDATE
      local DEFAULT_DEADLINE
      local UNEDITED_MILESTONE
      local EDITED_MILESTONE

    # Process input arguments
      local -A OPTIONS
      local -a ARGS
      local VALID_SHORT_FLAG_OPTIONS=( )
      local VALID_LONG_FLAG_OPTIONS=( )
      local VALID_SHORT_KEYVAL_OPTIONS=( -p      )
      local VALID_LONG_KEYVAL_OPTIONS=( --parent )
      local COMMAND_NAME="new_milestone"

      if   process_optargs "$@"
      then :
      else exit $EXIT_STATUS__INVALID_SUBCOMMAND_SYNTAX
      fi


    # Validate input arguments
      if   is_in '-p'       "${!OPTIONS[@]}" ;  then PARENT_MILESTONE="${OPTIONS[-p]}"
      elif is_in '--parent' "${!OPTIONS[@]}" ;  then PARENT_MILESTONE="${OPTIONS[--parent]}"
      fi

      if   test ${#ARGS[@]} -eq 0   # no arguments provided
      then :
      else error "Error: Incorrect arguments provided to new_milestone function"
           echo && display_usage
           exit $EXIT_STATUS__INVALID_SUBCOMMAND_SYNTAX
      fi


      cd "$MILESTONES_PATH"


    # If a parent milestone has been specified, check that this is valid before
    # proceeding

      if   test -n "$PARENT_MILESTONE"
      then PARENT_MILESTONE_FILE="${PARENT_MILESTONE%.milestone}.milestone"
           if   is_valid_milestone "$PARENT_MILESTONE"
           then PARENT_MILESTONE_NUM="${PARENT_MILESTONE_FILE%.milestone}"
           else error "Error: The specified parent milestone ('$PARENT_MILESTONE_FILE') does not exist in $MILESTONES_PATH. Aborting."
                return 1
           fi
      fi


    # If this is the first milestone, start numbering from 1; otherwise, find
    # the last milestone number, and increment by one.

      if     test -f 1.milestone
      then   LAST_MILESTONE_NUM=$(ls *.milestone | sort -n | tail -n -1)   # list files, sort in numerical (not alphabetical) order, and keep last filename
             LAST_MILESTONE_NUM=${LAST_MILESTONE_NUM%.milestone}   # parameter expansion: remove '.milestone' suffix
             NEW_MILESTONE_NUM=$(( $LAST_MILESTONE_NUM + 1 ))
      else   NEW_MILESTONE_NUM=1
      fi

      TEMP_FILE="$(tempfile).milestone"
      NEW_MILESTONE_FILE="${NEW_MILESTONE_NUM}.milestone"

    # Create a new milestone from template
      cp "$MILESTONE_TEMPLATE" "${TEMP_FILE}"

    # Update milestone number
      sed -i "s/Milestone No.: /Milestone No.: ${NEW_MILESTONE_NUM}/" "${TEMP_FILE}"

    # Set start date from default
      DEFAULT_STARTDATE="$(get_default_milestone_startdate)"
      sed -i "s/Startdate: /Startdate: $DEFAULT_STARTDATE/" "${TEMP_FILE}"

    # Update parent (milestone) node number
      sed -i "s/Parent Node: /Parent Node: $PARENT_MILESTONE_NUM/" "${TEMP_FILE}"

    # Set deadline from default
      DEFAULT_DEADLINE="$( get_default_milestone_deadline $DEFAULT_STARTDATE )"
      sed -i "s/Deadline: /Deadline: $DEFAULT_DEADLINE/" "${TEMP_FILE}"

    # Save current status of ticket before manual editing
      UNEDITED_MILESTONE="$(cat "$TEMP_FILE")"


    # Open the resulting file for editing (see 'editor' function), placing the cursor
    # at the Title field.

      editor "${TEMP_FILE}" 3 16

      EDITED_MILESTONE="$(cat "$TEMP_FILE")"

      if   test "$UNEDITED_MILESTONE" = "$EDITED_MILESTONE"
      then error "Error: No edits detected."
           error "       Aborting new milestone creation."
           rm "$TEMP_FILE"
           return 1
      else if   cp "$TEMP_FILE" "$NEW_MILESTONE_FILE"
           then :
           else error "Error: could not copy temporary milestone file to $MILESTONES_PATH"
                return 1
           fi
           echo
           echo "Milestone No. ${NEW_MILESTONE_NUM} created successfully"
           echo
      fi
   }




   function close_ticket_with_comment () {
    # --------------------------------------------------------------------------
    # Invoked via the 'close' subcommand.
    # Expects a ticket number (or filename) as an argument.
    # --------------------------------------------------------------------------

    # Ensure the function was called with a ticket number / filename
      if   test ${#@} -ne 1
      then error "Error: Incorrect arguments provided to close_ticket_with_comment function"
           echo
           display_usage
           return 1
      fi


      cd "$TICKETS_PATH"


    # Check specified ticket is valid
      TICKET="${1%.ticket}.ticket"
      if   is_valid_ticket "$TICKET"
      then :
      else echo "Error: Invalid ticket specified!" && return 1
      fi

    # Save state of original ticket in case we need to revert at the end
      ORIGINAL_TICKET="$(cat $TICKET)"

    # Get today's date
      TODAY=$(date +"%Y-%m-%d")

    # Check that ticket is actually open
      if   grep "Open/Closed: Open" $TICKET > /dev/null
      then :
      else error "Error: Ticket No. $TICKET is already marked as closed ($( egrep -o "Resolution: .*$" $TICKETS | cut -d' ' -f2 ))! Aborting." && return 1
      fi

    # Select an appropriate resolution
      echo "Closing ticket ${1} ($(grep -o "Summary: .*" "${TICKET}"))"
      echo
      echo "Select a resolution for this ticket:"
      declare -i REPLY   # The user's input is assigned to this variable; we want to ensure it only takes numeric values
      select RESOLUTION in "${TICKET_RESOLUTIONS[@]}"
      do
          if   test $REPLY -gt 0 && test $REPLY -le ${#TICKET_RESOLUTIONS[@]}
          then sed -i "s/Resolution: .*\$/Resolution: $RESOLUTION/" "${TICKET}"
               break
          else error "Error: Invalid selection, please chose a number between 1 and ${#TICKET_RESOLUTIONS[@]}" && return 1
          fi
      done
      declare +i REPLY

    # Clear 'ticket status' field (since this relates to 'Open' tickets).
      sed -i "s/Status: .*\$/Status: /" "${TICKET}"

    # Check if owner is set. If not, make me the owner.
      CURRENT_OWNER="$(grep -oP "(?<=Owner: ).*" "${TICKET}")"
      WHOAMI="$(whoami)"
      WHOAMI="${WHOAMI^}"   # parameter expansion: make first character uppercase
      if test -z "${CURRENT_OWNER}"   # If it's an empty string
      then
          sed -i "s/Owner: /Owner: $WHOAMI/" "${TICKET}"
          CURRENT_OWNER="$WHOAMI"
      fi

    # Start a new comment:
      echo             >> "${TICKET}"
      echo             >> "${TICKET}"
      echo "== $TODAY" >> "${TICKET}"

    # Leave empty line where the comment will go, and capture that line number
      echo >> "${TICKET}"
      LINENUM=$(cat "${TICKET}" | wc -l)

    # Finalise ticket closing.
      echo "Closing ticket." >> "${TICKET}"

    # If owner is different than closer, mention the closer's name in the closing comment explicitly
      if test "$CURRENT_OWNER" != "$WHOAMI"
      then
          echo "($WHOAMI)" >> "${TICKET}"
      fi

    # Mark as Closed
      sed -i "s/Open\/Closed: .*/Open\/Closed: Closed/" "${TICKET}"

    # Save current status of ticket before manual editing
      UNEDITED_TICKET="$(cat $TICKET)"

    # Open default editor and put cursor in the right place for editing
      editor "${TICKET}" $LINENUM 1

      EDITED_TICKET="$(cat $TICKET)"

      if   test "$UNEDITED_TICKET" = "$EDITED_TICKET"
      then error "Error: No edits detected."
           error "       'Close' operation aborted and ticket reverted to original state."
           echo "$ORIGINAL_TICKET" > "$TICKET"
           return 1
      fi
   }




   function add_comment_to_ticket () {
    # --------------------------------------------------------------------------
    # Invoked via 'add / comment' subcommand
    #
    # Expects a ticket number/filename as an input argument
    # --------------------------------------------------------------------------

    # Check function was called with an argument
      if   test ${#@} -ne 1
      then error "Error: Incorrect arguments provided to add_comment_to_ticket function"
           echo && display_usage add_comment_to_ticket
           exit $EXIT_STATUS__INVALID_SUBCOMMAND_SYNTAX
      fi


      cd "$TICKETS_PATH"


    # Check the provided ticket is valid
      TICKET="${1%.ticket}.ticket"
      if   is_valid_ticket "$TICKET"
      then :
      else error "Error: Invalid ticket specified!" && return 1
      fi

    # Save state of original ticket in case we need to revert at the end
      ORIGINAL_TICKET="$(cat $TICKET)"

    # Get today's date
      TODAY=$(date +"%Y-%m-%d")

    # Start a new comment:
      echo             >> "${TICKET}"
      echo             >> "${TICKET}"
      echo "== $TODAY" >> "${TICKET}"

    # Leave empty line where the comment will go, and capture that line number
      echo >> "${TICKET}"
      LINENUM=$(cat "${TICKET}" | wc -l)

    # If owner is different than closer, mention the closer's name in the closing comment explicitly
      if test "$CURRENT_OWNER" != "$WHOAMI"
      then
          echo "($WHOAMI)" >> "${TICKET}"
      fi

    # Save current status of ticket before manual editing
      UNEDITED_TICKET="$(cat $TICKET)"

    # Open default editor and put cursor in the right place for editing
      editor "${TICKET}" $LINENUM 1

      EDITED_TICKET="$(cat $TICKET)"

      if   test "$UNEDITED_TICKET" = "$EDITED_TICKET"
      then error "Error: No edits detected."
           error "       'Add comment' operation aborted and ticket reverted to original state."
           echo "$ORIGINAL_TICKET" > "$TICKET"
           return 1
      fi
   }




   function assign_tickets_to_milestone () {
    # --------------------------------------------------------------------------
    # Invoked via 'assign' subcommand.
    #
    # Expects two or more arguments. The last argument needs to be a milestone
    # to assign tickets to; the remaining should be valid tickets.
    # --------------------------------------------------------------------------

    # If called with the wrong number of arguments, display usage
      if   test "$#" -le 1
      then display_usage 'assign_tickets_to_milestone'
           exit $EXIT_STATUS__INVALID_SUBCOMMAND_SYNTAX
      fi

    # Process input arguments into tickets and a milestone
      local ARGS=( "$@" )                               # Get all positional arguments as a bash array
      local MILESTONE_ARG="${ARGS[-1]}"                 # Get the last element of the array
      local TICKET_ARGS=( "${ARGS[@]: 0 : $# - 1 }" )   # Create a sub-array, from index 0 to N-1
      local MILESTONE_NO
      local TICKET_NO
      local TICKET_FILE

    # Confirm validity of inputs
      local ERRORS=0

      for  TICKET_ARG in "${TICKET_ARGS[@]}"
      do   if   is_valid_ticket "$TICKET_ARG"
           then :
           else ERRORS=$((ERRORS + 1))
           fi
      done

      if   is_valid_milestone "$MILESTONE_ARG"
      then :
      else ERRORS=$((ERRORS + 1))
      fi

      if test "$ERRORS" -gt 0
      then error "Error: Encountered $ERRORS input errors. Aborting."
           return 1
      fi

    # Process all tickets
      MILESTONE_NO="${MILESTONE_ARG%.milestone}"   # Remove .milestone suffix
      MILESTONE_NO="${MILESTONE_NO%0}"             # If milestone was '0', use empty string instead.

      for  TICKET_ARG in "${TICKET_ARGS[@]}"
      do   TICKET_NO="${TICKET_ARG%.ticket}"
           TICKET_FILE="$TICKETS_PATH/${TICKET_NO}.ticket"
           sed -i "s/  Milestone: .*\$/  Milestone: ${MILESTONE_NO}/" "$TICKET_FILE"
      done

    # update milestones accordingly - note, we need to update ALL milestones, because more than one may have changed
      update_milestones
   }




   function update_milestones () {
    # --------------------------------------------------------------------------
    # Invoked via 'update' subcommand
    #
    # If called without arguments, performs a general update of all milestones.
    # Otherwise, expects a number of valid milestone numbers to update
    # selectively.
    #
    # To 'update' means to refresh the list of open and closed tickets for the
    # milestone. This is not implemented in a particularly super-efficient
    # manner at the moment (goes through all tickets for each milestone); but in
    # practice this is pretty fast anyway.
    # --------------------------------------------------------------------------

    # Confirm there are milestones present to begin with before proceeding
      if   test -f "$MILESTONES_PATH/1.milestone"
      then :
      else warning "Warning: No milestones found in '$MILESTONES_PATH'. Aborting update."
           return 1
      fi

      local ARGS
      local MILESTONE_NO
      local MILESTONE_FILE
      local HEADER
      local ERRORS

    # Process Input Arguments
      ARGS=( "$@" )   # Get all positional arguments as a bash array

      ERRORS=0

      if   test "${#ARGS[@]}" -eq 0                         # function was called without inputs

      then ARGS=( "$MILESTONES_PATH"/*.milestone )          # Collect all milestone filenames
           for  i in $( seq 0 "$(( ${#ARGS[@]} - 1))" )     # loop from index 0 to N-1
           do   ARGS["$i"]="${ARGS[$i]#$MILESTONES_PATH/}"  # Remove path prefix
                if   is_valid_milestone "${ARGS[$i]}"
                then :
                else ERRORS=$((ERRORS + 1))
                fi
           done

      else   # function was called with specific arguments

          for  ARG in "${ARGS[@]}"
          do   if   is_valid_milestone $ARG
               then :
               else ERRORS=$((ERRORS + 1))
               fi
          done
      fi

      if test "$ERRORS" -gt 0
      then error "Error: Encountered $ERRORS input errors. Aborting."
           return 1
      fi

    # Perform update on selected milestones
      for ARG in "${ARGS[@]}"
      do  MILESTONE_NO="${ARG%.milestone}"   # Remove .milestone suffix
          MILESTONE_FILE="$MILESTONES_PATH/${ARG%.milestone}.milestone"
          HEADER=$(grep --color=never "=== Open Tickets ===" "$MILESTONE_FILE" -n | cut -d: -f1 )

          head -n "+$HEADER" "$MILESTONE_FILE"              > "$MILESTONE_FILE.bak"
          echo                                             >> "$MILESTONE_FILE.bak"
          show_open_tickets_by_milestone "$MILESTONE_NO"   >> "$MILESTONE_FILE.bak"
          echo                                             >> "$MILESTONE_FILE.bak"
          echo                                             >> "$MILESTONE_FILE.bak"
          echo "=== Closed Tickets ==="                    >> "$MILESTONE_FILE.bak"
          echo                                             >> "$MILESTONE_FILE.bak"
          show_closed_tickets_by_milestone "$MILESTONE_NO" >> "$MILESTONE_FILE.bak"
          mv "$MILESTONE_FILE.bak" "$MILESTONE_FILE"
      done
   }




   function show_open_tickets_by_milestone () {
    # --------------------------------------------------------------------------
    # Invoked via 'list' ... FIXME
    #
    # Expects a single milestone number/filename.
    # If the number is "0", this will reflect 'unmilestoned' tickets.
    # --------------------------------------------------------------------------

    # If called without arguments or with more than one arguments, display usage
      if   test "$#" -ne 1
      then display_usage "show_open_tickets_by_milestone"
           exit $EXIT_STATUS__INVALID_SUBCOMMAND_SYNTAX
      fi

      local MILESTONE="${1%.milestone}"

      if   test "$MILESTONE" = "0"
      then MILESTONE=""
      elif is_valid_milestone "$MILESTONE"
      then :
      else error "Error: Encountered input errors. Aborting."
           return 1
      fi


      cd "$TICKETS_PATH"


      local MILESTONE_TICKETS=( $(egrep --color=never  -l "Milestone: $MILESTONE\$" *.ticket) )

      for  TICKET in "${MILESTONE_TICKETS[@]}"
      do   local TICKETNAME="$(grep -l --color=never 'Open/Closed: Open' "$TICKET")"
           local TICKETSUMMARY="$(grep --color=never "Summary: " "$TICKET")"
           if test -n "$TICKETNAME"
           then echo "$TICKETNAME $TICKETSUMMARY"
           fi
      done
   }




   function show_closed_tickets_by_milestone () {
    # --------------------------------------------------------------------------
    # Invoked via 'list' ... FIXME
    #
    # Expects a single milestone number/filename.
    # If the number is "0", this will reflect 'unmilestoned' tickets.
    # --------------------------------------------------------------------------

    # If called without arguments or with more than one arguments, display usage
      if   test "$#" -ne 1
      then display_usage "show_closed_tickets_by_milestone"
           exit $EXIT_STATUS__INVALID_SUBCOMMAND_SYNTAX
      fi

      local MILESTONE="${1%.milestone}"

      if   test "$MILESTONE" = "0"
      then MILESTONE=""
      elif is_valid_milestone "$MILESTONE"
      then :
      else error "Error: Encountered input errors. Aborting."
           return 1
      fi


      cd "$TICKETS_PATH"


      local MILESTONE_TICKETS=( $(egrep --color=never  -l "Milestone: $MILESTONE\$" *.ticket) )

      for  TICKET in "${MILESTONE_TICKETS[@]}"
      do   local TICKETNAME="$(grep -l --color=never 'Open/Closed: Closed' "$TICKET")"
           local TICKETSUMMARY="$(grep --color=never "Summary: " "$TICKET")"
           if test -n "$TICKETNAME"
           then echo "$TICKETNAME $TICKETSUMMARY"
           fi
      done
   }




   function show_active_milestones () {
    # --------------------------------------------------------------------------
    # Invoked via 'list'? 'report'? # FIXME
    #
    # Expects no arguments.
    #
    # Creates a report of milestones that still have open tickets (or are empty)
    # --------------------------------------------------------------------------

    # Confirm called without arguments
      if   test "$#" -gt 0
      then display_usage show_active_milestones
           exit $EXIT_STATUS__INVALID_SUBCOMMAND_SYNTAX
      fi

      local OPEN_LINE
      local CLOSE_LINE
      local NUM_OPEN_TICKETS
      local NUM_CLOSED_TICKETS
      local NUM_TICKETS
      local PERCENTAGE
      local DEADLINE
      local TODAY
      local DAYS_LEFT
      local d="[[:digit:]]"


      cd "$MILESTONES_PATH"


      for i in *.milestone
      do

        # Detect open and closed tickets
          OPEN_LINE=$(  grep --color=never -n "=== Open Tickets ==="   "$i" | cut -d: -f1 )
          CLOSE_LINE=$( grep --color=never -n "=== Closed Tickets ===" "$i" | cut -d: -f1 )
          NUM_OPEN_TICKETS=$( cat "$i" | head -n "+$(( CLOSE_LINE - 1 ))" | tail -n "+$(( OPEN_LINE + 1 ))" |  egrep "^\s*\$" -v | wc -l )
          NUM_CLOSED_TICKETS=$( cat "$i" | tail -n "+$(( CLOSE_LINE + 1 ))" |  egrep "^\s*\$" -v | wc -l )


          if   test $NUM_OPEN_TICKETS   -gt 0 ||   # if there are open tickets then milestone is not complete
               test $NUM_CLOSED_TICKETS -eq 0      # if milestone is empty, then it is not considered complete
          then :
          else continue
          fi


        # Calculate percentage completion
          NUM_TICKETS="$(( NUM_OPEN_TICKETS + NUM_CLOSED_TICKETS ))"
          if   test $NUM_TICKETS -eq 0
          then PERCENTAGE="Empty"
          else PERCENTAGE="$(( 100 * NUM_CLOSED_TICKETS / NUM_TICKETS ))%"
          fi

        # Calculate days left from deadline (assumes correct date format!)
          DEADLINE=$(grep --color=never "   Deadline: " "$i" | cut -d$':' -f2 )
          if   echo "$DEADLINE" | egrep "^ $d$d$d$d-$d$d-$d$d$" > /dev/null
          then DEADLINE=$(date --date "$DEADLINE" "+%s")
               TODAY=$(date "+%s")
               DAYS_LEFT=$(( (DEADLINE - TODAY) / 86400 ))
          else DAYS_LEFT="N/A"
          fi

        # Print entry to terminal (unsorted)
          printf "%-15s -- " "Milestone ${i%.milestone}"
          printf "%-27s -- " "Completion: $NUM_CLOSED_TICKETS / $NUM_TICKETS ($PERCENTAGE)"
          printf "%-15s -- " "Days left: ${DAYS_LEFT}"
          printf "Title: " && grep --color=never "      Title:" "$i" | cut -d$':' -f2
      done
   }




   function show_completed_milestones () {
    # ----------------------------------------------------------------------
    # Invoked via 'list'? 'report'? # FIXME
    #
    # Expects no arguments.
    #
    # Creates a report of (non-empty) milestones that no longer have tickets
    # open
    # ----------------------------------------------------------------------

    # Confirm called without arguments
      if   test "$#" -gt 0
      then display_usage show_completed_milestones
           exit $EXIT_STATUS__INVALID_SUBCOMMAND_SYNTAX
      fi

      local OPEN_LINE
      local CLOSE_LINE
      local CLOSED_TICKETS
      local NUM_OPEN_TICKETS
      local NUM_CLOSED_TICKETS
      local NUM_TICKETS
      local PERCENTAGE
      local DEADLINE
      local TODAY
      local DAYS_LEFT
      local d="[[:digit:]]"   # for convenience in later regular expressions


      cd "$MILESTONES_PATH"


      for i in *.milestone
      do

        # Detect open and closed tickets
          OPEN_LINE=$(  grep --color=never -n "=== Open Tickets ==="   "$i" | cut -d: -f1 )
          CLOSE_LINE=$( grep --color=never -n "=== Closed Tickets ===" "$i" | cut -d: -f1 )
          NUM_OPEN_TICKETS=$( cat "$i" | head -n "+$(( CLOSE_LINE - 1 ))" | tail -n "+$(( OPEN_LINE + 1 ))" |  egrep "^\s*\$" -v | wc -l )
          CLOSED_TICKETS=( $(cat "$i" | tail -n "+$(( CLOSE_LINE + 1 ))" | egrep --color=never -o "^.+\.ticket\b" ) )
          NUM_CLOSED_TICKETS="${#CLOSED_TICKETS[@]}"

          if   test $NUM_OPEN_TICKETS   -gt 0 ||   # if there are open tickets then milestone is not complete
               test $NUM_CLOSED_TICKETS -eq 0      # if milestone is empty, then it is not considered complete
          then continue
          else : # Past this point, we assume this milestones has no open tickets, and
                 # has at least one closed ticket
          fi

        # Determine final date of ticket with most recent activity
          COMPLETION_DATE=$( for  t in "${CLOSED_TICKETS[@]}"
                             do   egrep "== $d{4}-$d{2}-$d{2}" "../tickets/$t" | cut -b 4-
                             done | sort | head -n +1 )

        # Calculate difference from deadline (assumes correct date format!)
          DEADLINE=$(grep --color=never "   Deadline: " "$i" | cut -d$':' -f2 )
          DEADLINE=$(date --date "$DEADLINE" "+%s")
          COMPLETION_DATE_SECONDS=$( date --date "$COMPLETION_DATE" "+%s" )
          DATEDIFF=$(( (DEADLINE - COMPLETION_DATE_SECONDS) / 86400 ))

          if   test $((DATEDIFF)) -eq 0; then DATESTR="on time"
          elif test $((DATEDIFF)) -gt 0; then DATESTR="$DATEDIFF days ahead of deadline"
          else                                DATESTR="$((-DATEDIFF)) days late"
          fi

        # Print entry to terminal (unsorted)
          printf "%-15s -- " "Milestone ${i%.milestone}"
          printf "%-27s -- " "${NUM_CLOSED_TICKETS} tickets completed"
          printf "%s -- " "Last ticket completed on: $COMPLETION_DATE ($DATESTR)"
          printf "Title: " && grep --color=never "      Title:" "$i" | cut -d$':' -f2
      done
   }




   function edit_ticket () {
    # -----------------------------------------------------------
    # Invoked via 'edit ticket' or 'et' subcommand
    #
    # Calls the 'editor' helper function on the specified ticket.
    #
    # Note: only supports editing one file at a time.
    # -----------------------------------------------------------

    # Confirm called with a single argument
      if   test "$#" -eq 1
      then :
      else display_usage edit_ticket
           exit $EXIT_STATUS__INVALID_SUBCOMMAND_SYNTAX
      fi

      local TICKET="${1%.ticket}.ticket"

      if   is_valid_ticket "$TICKET"
      then :
      else error "Error: Could not open ticket '$TICKETS_PATH/$TICKET' for editing"
           return 1
      fi

      editor "$TICKETS_PATH/$TICKET" 1 1
   }




   function edit_milestone () {
    # --------------------------------------------------------------
    # Invoked via 'edit milestone' or 'em' subcommand
    #
    # Calls the 'editor' helper function on the specified milestone.
    #
    # Note: only supports editing one file at a time.
    # --------------------------------------------------------------

    # Confirm called without arguments
      if   test "$#" -eq 1
      then :
      else display_usage edit_milestone
           exit $EXIT_STATUS__INVALID_SUBCOMMAND_SYNTAX
      fi

      local MILESTONE="${1%.milestone}.milestone"

      if   is_valid_milestone "$MILESTONE"
      then :
      else error "Error: Could not open ticket '$MILESTONES_PATH/$MILESTONE' for editing"
           return 1
      fi

      editor "$MILESTONES_PATH/$MILESTONE" 1 1
   }




   function edit_ticket_or_milestone () {
    # --------------------------------------------------------------------------
    # Invoked via the 'edit' subcommand.
    #
    # Expects to be called as either 'edit ticket' or 'edit milestone', and
    # delegates to the 'edit_ticket' or 'edit_milestone' functions as appropriate,
    # passing all remaining arguments given during invocation.
    # --------------------------------------------------------------------------
      case "$1" in
          ("ticket")     shift && edit_ticket    "$@" ;;
          ("milestone")  shift && edit_milestone "$@" ;;
          (*)            error "Error: Invalid argument given to 'edit'."
                         error "       Valid arguments are 'ticket' or 'milestone'."
                         return 1 ;;
      esac
   }




   function view_ticket_or_milestone () {
    # --------------------------------------------------------------------------
    # Invoked via the 'view' subcommand.
    #
    # Expects to be called as either 'view ticket' or 'view milestone', and
    # delegates to the 'view_ticket' or 'view_milestone' functions as appropriate,
    # passing all remaining arguments given during invocation.
    # --------------------------------------------------------------------------
      case "$1" in
          ("ticket")     shift && view_ticket    "$@" ;;
          ("milestone")  shift && view_milestone "$@" ;;
          (*)            error "Error: Invalid argument given to 'view'."
                         error "       Valid arguments are 'ticket' or 'milestone'."
                         return 1 ;;
      esac
   }




   function view_ticket () {
    # ----------------------------------------------------------
    # Invoked via 'view ticket' or 'vt' subcommands
    #
    # Expects a single argument corresponding to a valid ticket.
    #
    # Applies nice colouring, and then calls less on the result
    # ----------------------------------------------------------

      local TICKET="${1%.ticket}.ticket"
      local d="[[:digit:]]"   # for convenience in later regular expressions

      if   is_valid_ticket "$TICKET"
      then :
      else return 1
      fi

      DESCRIPTION_LINE=$(grep --color=never "Description: " "$TICKETS_PATH/$TICKET" -n | cut -d: -f1 )
      PRE_DESCRIPTION_LINE=$(( DESCRIPTION_LINE - 1 ))
      POST_DESCRIPTION_LINE=$(( DESCRIPTION_LINE + 1 ))

      PRINTOUT="$( head -n "+$PRE_DESCRIPTION_LINE" "$TICKETS_PATH/$TICKET" | sed "s/^\(...........\)\(.*\)\$/${ANSI_BLUE}\1${ANSI_YELLOW}\2${ANSI_RESET}/" )"$'\n'
      PRINTOUT="$PRINTOUT$( head -n "+$DESCRIPTION_LINE" "$TICKETS_PATH/$TICKET" | tail -n -1 | sed "s/\(...........\)\(:\)/${ANSI_BLUE}\1${ANSI_YELLOW}\2${ANSI_RESET}/" )"$'\n'
      PRINTOUT="$PRINTOUT$( tail -n "+$POST_DESCRIPTION_LINE" "$TICKETS_PATH/$TICKET" | sed "s/^\(== $d$d$d$d-$d$d-$d$d\)/${ANSI_BOLD_ON}${ANSI_BLUE}\1${ANSI_BOLD_OFF}${ANSI_RESET}/" )"$'\n'
      echo "$PRINTOUT" | less -R
   }




   function view_milestone () {
    # ----------------------------------------------------------
    # Invoked via 'view ticket' or 'vt' subcommands
    #
    # Expects a single argument corresponding to a valid ticket.
    #
    # Applies nice colouring, and then calls less on the result
    # ----------------------------------------------------------

      local MILESTONE="${1%.milestone}.milestone"
      local PRINTOUT

      if   is_valid_milestone "$MILESTONE"
      then :
      else return 1
      fi

      DESCRIPTION_LINE="$(grep --color=never "  Description: " "$MILESTONES_PATH/$MILESTONE" -n | cut -d: -f1 )"
      POST_DESCRIPTION_LINE=$(( DESCRIPTION_LINE + 1 ))

      PRINTOUT="$( head -n "+$DESCRIPTION_LINE" "$MILESTONES_PATH/$MILESTONE" )"
      PRINTOUT="$( echo "$PRINTOUT" | sed "s/^\(.............\)\(.*\)\$/${ANSI_BLUE}\1${ANSI_YELLOW}\2${ANSI_RESET}/" )"$'\n'
      PRINTOUT="${PRINTOUT}$( tail -n "+$POST_DESCRIPTION_LINE" "$MILESTONES_PATH/$MILESTONE" )"
      PRINTOUT="$( echo "$PRINTOUT" | sed "s/=== Open Tickets ===/${ANSI_BOLD_ON}${ANSI_RED}=== Open Tickets ===${ANSI_BOLD_OFF}${ANSI_RESET}/" )"
      PRINTOUT="$( echo "$PRINTOUT" | sed "s/=== Closed Tickets ===/${ANSI_BOLD_ON}${ANSI_GREEN}=== Closed Tickets ===${ANSI_BOLD_OFF}${ANSI_RESET}/" )"
      echo "$PRINTOUT" | less -R
   }




   function list_tickets_or_milestones () {
    # --------------------------------------------------------------------------
    # Invoked via the 'list' subcommand.
    #
    # Expects to be called as either 'list tickets' or 'list milestones', and
    # delegates to the 'list_tickets' or 'list_milestones' functions as
    # appropriate, passing all remaining arguments given during invocation.
    # --------------------------------------------------------------------------

      case "$1" in
          ("tickets")     shift && list_tickets    "$@" ;;
          ("milestones")  shift && list_milestones "$@" ;;
          (*)             error "Error: Invalid argument given to 'list'."
                          error "       Valid arguments are 'tickets' or 'milestones'."
                          return 1 ;;
      esac

   }


   function list_tickets () {
    # --------------------------------------------------------------------------
    # Invoked via the 'list tickets', 'listtickets', or 'lt' commands
    #
    # TODO
    # --------------------------------------------------------------------------

      true ;
   }





 # ----------------
 # Legacy Functions
 # ----------------

   function show_all_ticket_summaries () {
    # --------------------------------------------------------------------------
    # XXX: Currently invoked via show_all_ticket_summaries legacy subcommand.
    #      This will be eventually be replaced via a single 'show' or 'list'
    #      subcommand.
    #
    # Expects no arguments.
    # --------------------------------------------------------------------------

    # Check if called with no arguments
      if   test ${#@} -gt 0
      then error "Error: show_all_ticket_summaries does not expect any arguments."
           display_usage "show_all_ticket_summaries"
           exit $EXIT_STATUS__INVALID_SUBCOMMAND_SYNTAX
      fi


      cd "$TICKETS_PATH"


      for i in *.ticket
      do

       # Mark open tickets with a red, 'Open' tag.
         if   grep 'Open/Closed: Open' "$i" > /dev/null
         then echo -en "$i: ${ANSI_RED}[ Open ]${ANSI_RESET} "

       # Mark closed tickets with a green, 'Closed' tag.
         elif grep 'Open/Closed: Closed' "$i" > /dev/null
         then echo -en "$i: ${ANSI_GREEN}[Closed]${ANSI_RESET} "

       # Mark tickets of unknown or missing status with a purple '????' tag.
         else echo -en "$i: ${ANSI_PURPLE}[ ???? ]${ANSI_RESET} "
         fi

       # Add summary to tag.
         grep Summary "$i"

      done
   }




   function show_closed_ticket_resolutions () {
    # --------------------------------------------------------------------------
    # XXX: Currently invoked via show_closed_ticket_resolutions legacy
    #      subcommand. This will be eventually be replaced via a single 'show'
    #      or 'list' subcommand.
    #
    # Expects no arguments.
    # --------------------------------------------------------------------------

      if   test ${#@} -gt 0
      then error "Error: show_closed_ticket_resolutions does not expect any arguments."
           display_usage "show_closed_ticket_resolutions"
           exit $EXIT_STATUS__INVALID_SUBCOMMAND_SYNTAX
      fi

      local TICKET

      cd "$TICKETS_PATH"

      for TICKET in $(grep --color=never -l 'Open/Closed: Closed' *.ticket)
      do
          echo -n "$TICKET "
          grep --color=always "Resolution:" "$TICKET"        \
              | sed "s/Completed/\\x1b[92mCompleted\\x1b[39m/" \
              | sed "s/Delegated/\\x1b[94mDelegated\\x1b[39m/" \
              | sed "s/Postponed/\\x1b[93mPostponed\\x1b[39m/" \
              | sed "s/Cancelled/\\x1b[91mCancelled\\x1b[39m/" \
              | sed "s/Invalid/\\x1b[95mInvalid\\x1b[39m/"

      done
   }




   function show_closed_ticket_summaries () {
    # --------------------------------------------------------------------------
    # XXX: Currently invoked via show_closed_ticket_summaries legacy
    #      subcommand. This will be eventually be replaced via a single 'show'
    #      or 'list' subcommand.
    #
    # Expects no arguments.
    # --------------------------------------------------------------------------

      if   test ${#@} -gt 0
      then error "Error: show_closed_ticket_summaries does not expect any arguments."
           display_usage "show_closed_ticket_summaries"
           exit $EXIT_STATUS__INVALID_SUBCOMMAND_SYNTAX
      fi


      cd "$TICKETS_PATH"
      local COUNT=0

      for i in *.ticket
      do
        if   grep 'Open/Closed: Closed' "$i" > /dev/null
        then COUNT=$((COUNT + 1))
             echo -n "$i:"
             grep Summary "$i"
        fi
      done

      echo
      echo "There are $COUNT closed tickets in total."
   }




   function show_open_ticket_summaries () {
    # --------------------------------------------------------------------------
    # XXX: Currently invoked via show_open_ticket_summaries legacy
    #      subcommand. This will be eventually be replaced via a single 'show'
    #      or 'list' subcommand.
    #
    # Expects no arguments.
    # --------------------------------------------------------------------------

      if   test ${#@} -gt 0
      then error "Error: show_open_ticket_summaries does not expect any arguments."
           display_usage "show_open_ticket_summaries"
           exit $EXIT_STATUS__INVALID_SUBCOMMAND_SYNTAX
      fi

      cd "$TICKETS_PATH"
      local COUNT=0

      for i in *.ticket
      do
        if   grep 'Open/Closed: Open' "$i" > /dev/null
        then COUNT=$((COUNT + 1))
             echo -n "$i:"
             grep Summary "$i"
        fi
      done

      echo
      echo "There are $COUNT open tickets in total."
   }




   function show_open_ticket_summaries_by_owner () {
    # --------------------------------------------------------------------------
    # XXX: Currently invoked via show_open_ticket_summaries_by_owner legacy
    #      subcommand. This will be eventually be replaced via a single 'show'
    #      or 'list' subcommand.
    #
    # Expects no arguments.
    # --------------------------------------------------------------------------

      if   test ${#@} -gt 0
      then error "Error: show_open_ticket_summaries_by_owner does not expect any arguments."
           display_usage "show_open_ticket_summaries_by_owner"
           exit $EXIT_STATUS__INVALID_SUBCOMMAND_SYNTAX
      fi

      cd "$TICKETS_PATH"

      local OWNERS="$( grep --color=never 'Owner:' *.ticket | cut -d: -f3 | cut -b 2- | sort -u )"

      while read -r OWNER
      do
         local OWNERS_TICKETS="$( egrep -l "Owner: ${OWNER}$" *.ticket )"

         local COUNT=0
         local PRINTOUT=

         for i in $OWNERS_TICKETS;
         do
           if   grep 'Open/Closed: Open' "$i" > /dev/null
           then COUNT=$((COUNT + 1))
                PRINTOUT="$PRINTOUT$i:"
                PRINTOUT="$PRINTOUT $(grep Summary "$i")"$'\n'
           fi
         done

         echo -e "${ANSI_BLUE}== ${ANSI_BOLD_ON}Owner: ${OWNER:-(Nobody)}${ANSI_BOLD_OFF} (${COUNT} open tickets)${ANSI_RESET}"
         echo "$PRINTOUT"

      done <<< "$OWNERS"
   }




   function show_open_ticket_summaries_by_priority () {
    # --------------------------------------------------------------------------
    # XXX: Currently invoked via show_open_ticket_summaries_by_priority legacy
    #      subcommand. This will be eventually be replaced via a single 'show'
    #      or 'list' subcommand.
    #
    # Expects no arguments.
    # --------------------------------------------------------------------------

      if   test ${#@} -gt 0
      then error "Error: show_open_ticket_summaries_by_priority does not expect any arguments."
           display_usage "show_open_ticket_summaries_by_priority"
           exit $EXIT_STATUS__INVALID_SUBCOMMAND_SYNTAX
      fi


      cd "$TICKETS_PATH"

      for PRIORITY in Lowest Normal Important Urgent Highest
      do

         local PRIORITY_TICKETS=$(grep -l "Priority: $PRIORITY" *.ticket)
         local COUNT=0
         local PRINTOUT=

         for i in $PRIORITY_TICKETS;
         do


           if   grep 'Open/Closed: Open' "$i" > /dev/null
           then COUNT=$((COUNT + 1))
                PRINTOUT="$PRINTOUT$i:"
                PRINTOUT="$PRINTOUT $(grep Summary "$i")"$'\n'
           fi
        done

        echo -e "${ANSI_BLUE}== Priority: ${ANSI_BOLD_ON}${PRIORITY}${ANSI_BOLD_OFF} (${COUNT} open tickets)${ANSI_RESET}"
        echo "$PRINTOUT"

      done
   }



#############
### Main body
#############

 # -----------------------------
 # Perform initial sanity checks
 # -----------------------------

 # Ensure we have a valid bashtickets installation
   trycatch "check_bashtickets_installation" $EXIT_STATUS__INVALID_BASHTICKETS_INSTALLATION

 # Ensure valid bashtickets repository for commands that require it
   case "$1" in

       ( "init"   | "help"    | "h" )
           ;;   # do nothing for now


       ( "a"             | "add"           | "assign"        | "cl"  | \
         "close"         | "comment"       | "edit"          | "em"  | \
         "et"            | "list"          | "ls"            | "m"   | \
         "new"           | "newmilestone"  | "newticket"     | "nm"  | \
         "nt"            | "op"            | "open"          | "re"  | \
         "remove"        | "reopen"        | "rm"            | "sh"  | \
         "show"          | "st"            | "status"        | "up"  | \
         "update"        | "view"          | "vm"            | "vt"    \
       )

           trycatch "check_repo" \
                    $EXIT_STATUS__NOT_A_VALID_BASHTICKETS_REPOSITORY

           load_config
           check_for_nocolor
           ;;

       ( * )   ;;
   esac   # FIXME UPDATE MENU AS APPROPRIATE


 # -------------------------------------
 # Parse and execute bashtickets command
 # -------------------------------------


   case "$1" in
       ("update" | "up")                    trycatch update_milestones $EXIT_STATUS__OTHER_ERROR ;;
       ("show" | "sh" | "list" | "ls" )     shift && trycatch list_tickets_or_milestones  "$@" $EXIT_STATUS__FAILED_TO_LIST_TICKETS_OR_MILESTONES  ;;
       ( "add" | "comment" | "a" | "m")     shift && trycatch add_comment_to_ticket       "$@" $EXIT_STATUS__FAILED_TO_ADD_COMMENT_TO_TICKET       ;;
       ("assign")                           shift && trycatch assign_tickets_to_milestone "$@" $EXIT_STATUS__FAILED_TO_ASSIGN_TICKETS_TO_MILESTONE ;;
       ("close" | "cl")                     shift && trycatch close_ticket_with_comment   "$@" $EXIT_STATUS__FAILED_TO_CLOSE_TICKET                ;;
       ("open" | "reopen" | "re" | "op" )   shift && trycatch reopen_ticket               "$@" $EXIT_STATUS__FAILED_TO_REOPEN_TICKET               ;;
       ("new" | "create" )                  shift && trycatch new_ticket_or_milestone     "$@" $EXIT_STATUS__FAILED_TO_CREATE_TICKET_OR_MILESTONE  ;;
       ("nt" | "newticket" )         shift && trycatch new_ticket                  "$@" $EXIT_STATUS__FAILED_TO_CREATE_TICKET               ;;
       ("nm" | "newmilestone" )      shift && trycatch new_milestone               "$@" $EXIT_STATUS__FAILED_TO_CREATE_MILESTONE            ;;
       ("init")                             shift && trycatch create_or_initialise_bashtickets_repository "$@" $EXIT_STATUS__FAILED_TO_CREATE_OR_INITIALIZE_REPOSITORY ;;
       ("help" | "h")                       display_help ;;
       ("status" | "st")                    echo "Displaying milestone status (all/open/closed)...TODO" ;;
       ("remove" | "rm")                    echo "Removing last ticket / milestone or by number...TODO" ;;
       ("edit" | "ed")                      shift && trycatch edit_ticket_or_milestone "$@" $EXIT_STATUS__FAILED_TO_EDIT_TICKET_OR_MILESTONE ;;
       ("et")                               shift && trycatch edit_ticket              "$@" $EXIT_STATUS__FAILED_TO_EDIT_TICKET              ;;
       ("em")                               shift && trycatch edit_milestone           "$@" $EXIT_STATUS__FAILED_TO_EDIT_MILESTONE           ;;
       ("view")                             shift && trycatch view_ticket_or_milestone "$@" $EXIT_STATUS__OTHER_ERROR ;;
       ("vt")                               shift && trycatch view_ticket              "$@" $EXIT_STATUS__OTHER_ERROR ;;
       ("vm")                               shift && trycatch view_milestone           "$@" $EXIT_STATUS__OTHER_ERROR ;;


     # -------------------------------------------------------------------------
     # Let's also include "fullname" subcommands ... this is mostly for testing.
     # -------------------------------------------------------------------------

       # FIXME: REMOVE WHEN NO LONGER NEEDED

     # subcommands that take arguments
       ("show_open_tickets_by_milestone")   shift && trycatch show_open_tickets_by_milestone   "$@" $EXIT_STATUS__OTHER_ERROR ;;
       ("show_closed_tickets_by_milestone") shift && trycatch show_closed_tickets_by_milestone "$@" $EXIT_STATUS__OTHER_ERROR ;;
       ("edit_ticket_or_milestone")         shift && trycatch edit_ticket_or_milestone         "$@" $EXIT_STATUS__FAILED_TO_EDIT_TICKET_OR_MILESTONE ;;
       ("edit_ticket")                      shift && trycatch edit_ticket                      "$@" $EXIT_STATUS__FAILED_TO_EDIT_TICKET              ;;
       ("edit_milestone")                   shift && trycatch edit_milestone                   "$@" $EXIT_STATUS__FAILED_TO_EDIT_MILESTONE           ;;

     # subcommands that take no arguments
       ("show_active_milestones")                 trycatch show_active_milestones                 $EXIT_STATUS__OTHER_ERROR ;;
       ("show_completed_milestones")              trycatch show_completed_milestones              $EXIT_STATUS__OTHER_ERROR ;;
       ("show_all_ticket_summaries")              trycatch show_all_ticket_summaries              $EXIT_STATUS__OTHER_ERROR ;;
       ("show_closed_ticket_resolutions")         trycatch show_closed_ticket_resolutions         $EXIT_STATUS__OTHER_ERROR ;;
       ("show_closed_ticket_summaries")           trycatch show_closed_ticket_summaries           $EXIT_STATUS__OTHER_ERROR ;;
       ("show_open_ticket_summaries")             trycatch show_open_ticket_summaries             $EXIT_STATUS__OTHER_ERROR ;;
       ("show_open_ticket_summaries_by_owner")    trycatch show_open_ticket_summaries_by_owner    $EXIT_STATUS__OTHER_ERROR ;;
       ("show_open_ticket_summaries_by_priority") trycatch show_open_ticket_summaries_by_priority $EXIT_STATUS__OTHER_ERROR ;;


       ("")                                 display_usage "bashtickets" && exit 0 ;;
       (*)                                  display_usage && exit $EXIT_STATUS__INVALID_SUBCOMMAND ;;
   esac


### END OF SCRIPT
