#!/bin/bash

# Usage: close_ticket_with_comment <ticket number>   # e.g. 023

  if   test ${#@} -ne 1
  then error "Error: Incorrect arguments provided to new_milestone function"
       echo
       "$BT_UTILS_DIR/display_usage"
       exit 1
  fi

## Note: the 'error' function used here is defined in the main bashtickets
  # script and exported here

# Note: no 'valid repo' sanity checks here, since they will have been already
# performed by the main 'bashtickets' executable

# 'Import' arrays defined in config
  source "$CONFIG_FILE"

# Capture ticket path and template onto the relevant variables
  TICKETS_PATH="$( realpath ./tickets )"

  cd $TICKETS_PATH

# This is the ticket file we're about to modify
  TICKET="${1%.ticket}.ticket"
  if test -f "$TICKET"
  then :
  else echo "Error: Invalid ticket specified; file ${TICKET} does not exist!" && exit 1
  fi

# Save state of original ticket in case we need to revert at the end
  ORIGINAL_TICKET="$(cat $TICKET)"

# Get today's date
  TODAY=$(date +"%Y-%m-%d")

# Check that ticket is actually open
  grep "Status: Open" $TICKET > /dev/null
  if     test $? -eq 0
  then   :
  else   echo "Ticket No. $TICKET is not marked as Open! Please reopen if necessary." && exit
  fi

# Select an appropriate resolution
  echo "Closing ticket ${1} ($(grep -o "Summary: .*" "${TICKET}"))"
  echo
  echo "Select a resolution for this ticket:"
  declare -i REPLY   # The user's input is assigned to this variable; we want to ensure it only takes numeric values
  select RESOLUTION in "${TICKET_RESOLUTIONS[@]}"
  do
      if   test $REPLY -gt 0 && test $REPLY -le ${#TICKET_RESOLUTIONS[@]}
      then sed -i "s/Resolution: .*\$/Resolution: $RESOLUTION/" "${TICKET}"
           break
      else error "Invalid selection, please chose a number between 1 and ${#TICKET_RESOLUTIONS[@]}" && exit 1
      fi
  done
  declare +i REPLY

# Check if owner is set. If not, make me the owner.
  CURRENT_OWNER=$(grep -oP "(?<=Owner: ).*" "${TICKET}")
  WHOAMI=$(whoami)
  WHOAMI=${WHOAMI^}   # parameter expansion: make first character uppercase
  if test -z ${CURRENT_OWNER}   # If it's an empty string
  then
      sed -i "s/Owner: /Owner: $WHOAMI/" "${TICKET}"
      CURRENT_OWNER="$WHOAMI"
  fi

# Start a new comment:
  echo             >> "${TICKET}"
  echo             >> "${TICKET}"
  echo "== $TODAY" >> "${TICKET}"

# Leave empty line where the comment will go, and capture that line number
  echo >> "${TICKET}"
  LINENUM=$(cat "${TICKET}" | wc -l)

# Finalise ticket closing.
  echo "Closing ticket." >> "${TICKET}"

# If owner is different than closer, mention the closer's name in the closing comment explicitly
  if test "$CURRENT_OWNER" != "$WHOAMI"
  then
      echo "($WHOAMI)" >> "${TICKET}"
  fi

# Change status to Closed
  sed -i "s/Status: .*/Status: Closed/" "${TICKET}"

# Save current status of ticket before manual editing
  UNEDITED_TICKET="$(cat $TICKET)"

# Open default editor and put cursor in the right place for editing
  if   test $EDITOR == "vim"
  then vim  +"$LINENUM" "${TICKET}"
  else nano +"$LINENUM" "${TICKET}"
  fi

  EDITED_TICKET="$(cat $TICKET)"

  if   test "$UNEDITED_TICKET" = "$EDITED_TICKET"
  then error "Error: No edits detected."
       error "'Close' operation aborted and ticket reverted to original state."
       echo "$ORIGINAL_TICKET" > "$TICKET"
       exit 1
  fi
